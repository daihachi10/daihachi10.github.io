<!DOCTYPE html>
<html lang="JP">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tetris</title>
<style>
    body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        background-color: rgba(40, 40, 40, 1);
        margin: 0;
    }

    canvas {
        border: 1px solid #fff;
    }

    #controls {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 10px;
    }

    button {
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
    }
</style>

<body>
    <canvas id="tetris" width="240" height="400"></canvas>
    <canvas id="hold" width="60" height="60"></canvas>
    <div id="controls">
        <button onclick="playerMove(-1)">←</button>
        <button onclick="playerRotate(1)">⟳</button>
        <button onclick="playerMove(1)">→</button>
        <button onclick="playerDrop()">↓</button>
        <button onclick="playerDropInstant()">⤓</button>
        <button onclick="playerHold()">HOLD</button>
    </div>

    <script>
        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        const holdCanvas = document.getElementById('hold');
        const holdContext = holdCanvas.getContext('2d');

        const gameConfig = {
            blockSize: 20,
            holdBlockSize: 20,
            backgroundColor: 'rgb(40, 40, 40)',
            gridColor: '#333',
            colors: [null, '#dc2171', '#ff708f', '#ffb5cf', '#a6c7ff', '#7397e6', '#3e69b3', '#003f83'],
            dropInterval: 1000,
        };

        context.scale(gameConfig.blockSize, gameConfig.blockSize);
        holdContext.scale(gameConfig.holdBlockSize, gameConfig.holdBlockSize);

        const arena = createMatrix(12, 20);
        const player = { pos: { x: 0, y: 0 }, matrix: null, score: 0 };
        let holdPiece = null;
        let holdUsed = false;

        function createMatrix(width, height) {
            const matrix = [];
            while (height--) {
                matrix.push(new Array(width).fill(0));
            }
            return matrix;
        }

        function createPiece(type) {
            if (type === 'T') return [[0, 1, 0], [1, 1, 1], [0, 0, 0]];
            if (type === 'O') return [[2, 2], [2, 2]];
            if (type === 'L') return [[0, 3, 0], [0, 3, 0], [0, 3, 3]];
            if (type === 'J') return [[0, 4, 0], [0, 4, 0], [4, 4, 0]];
            if (type === 'I') return [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]];
            if (type === 'S') return [[0, 6, 6], [6, 6, 0], [0, 0, 0]];
            if (type === 'Z') return [[7, 7, 0], [0, 7, 7], [0, 0, 0]];
        }

        function drawMatrix(matrix, offset, ctx) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = gameConfig.colors[value];
                        ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                    }
                });
            });
        }

        function drawHold() {
            holdContext.fillStyle = gameConfig.backgroundColor;
            holdContext.fillRect(0, 0, holdCanvas.width, holdCanvas.height);
            if (holdPiece) {
                drawMatrix(holdPiece, { x: 0, y: 0 }, holdContext);
            }
        }

        function playerHold() {
            if (holdUsed) return;
            if (!holdPiece) {
                holdPiece = player.matrix;
                playerReset();
            } else {
                [holdPiece, player.matrix] = [player.matrix, holdPiece];
                player.pos = { x: (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0), y: 0 };
            }
            holdUsed = true;
            drawHold();
        }

        function playerReset() {
            const pieces = 'ILJOTSZ';
            player.matrix = createPiece(pieces[pieces.length * Math.random() | 0]);
            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            holdUsed = false;
        }

        function draw() {
            context.fillStyle = gameConfig.backgroundColor;
            context.fillRect(0, 0, canvas.width, canvas.height);
            drawMatrix(arena, { x: 0, y: 0 }, context);
            drawMatrix(player.matrix, player.pos, context);
        }

        function update() {
            draw();
            requestAnimationFrame(update);
        }

        playerReset();
        drawHold();
        update();
    </script>
</body>

</html>