<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ルーレット | daihachi</title>
    <style>
      :root {
        --logo-color: #1db31d;
        --color-primary: #1a73e8;
        --color-primary-dark: #0f3d7a;
        --color-primary-light: #e8f0fe;
        --color-primary-disabled: #a0c3f0;
        --color-accent: #e94560;
        --color-text-primary: #333;
        --color-text-secondary: #5f6368;
        --color-white: #ffffff;
        --color-bg: #f0f2f5;
        --color-bg-alt: #f8f9fa;
        --color-bg-secondary: #e0e0e0;
        --color-bg-secondary-hover: #c7c7c7;
        --color-bg-focus: #dbe4f0;
        --color-border: #ddd;
        --color-border-light: #e0e2e5;
        --color-card: #4a90e2;
        --color-card-back: #f7f7f7;
        --color-neutral-dark: #34495e;
        --shadow-color-light: rgba(0, 0, 0, 0.1);
        --shadow-color-medium: rgba(0, 0, 0, 0.15);
        --overlay-bg: rgba(0, 0, 0, 0.6);
        --roulette-number-bg: rgba(255, 255, 255, 0.8);
        --radius: 50px;
      }

      /* 基本スタイル */
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        background-color: var(--color-bg);
        color: var(--color-text-primary);
        display: flex;
        justify-content: center;
        align-items: center; /* 垂直方向も中央揃えに */
        min-height: 100vh;
        margin: 0;
        padding: 20px;
        box-sizing: border-box;
        transition: background-color 0.5s ease;
      }

      .home {
        font-family: "Caveat", cursive;
        text-decoration: none;
        font-size: 20px;
        width: 25px;
        height: 25px;
        position: absolute;
        bottom: 20px;
        right: 70px;
        color: var(--color-primary);
      }

      /* フォーカスモード時の背景 */
      body.focus-mode-on {
        background-color: var(--color-bg-focus);
      }

      .container {
        background-color: var(--color-white);
        padding: 30px 40px;
        border-radius: 16px;
        box-shadow: 0 8px 25px var(--shadow-color-light);
        text-align: center;
        width: 100%;
        max-width: 450px;
        position: relative;
        transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* フォーカスモード時のコンテナスタイル */
      .focus-mode-on .container {
        max-width: 80vw;
        height: 80vh;
        box-shadow: 0 15px 40px var(--shadow-color-medium);
      }

      /* 右上のボタングループ */
      .top-right-buttons {
        position: absolute;
        top: 15px;
        right: 15px;
        display: flex;
        gap: 10px;
        z-index: 20;
        align-items: center;
      }

      .profile-name-display {
        font-size: 0.9rem;
        color: var(--color-text-secondary);
        margin-right: 10px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100px;
        transition: opacity 0.3s ease;
      }

      .focus-mode-on .profile-name-display {
        opacity: 0;
        pointer-events: none;
      }

      /* フォーカス切り替えボタン */
      .focus-toggle-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: var(--color-bg);
        border: 1px solid var(--color-border-light);
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0;
        transition: all 0.3s ease;
      }
      .focus-toggle-btn:hover {
        background-color: var(--color-primary-light);
        border-color: var(--color-primary-disabled);
      }
      .focus-toggle-btn svg {
        width: 20px;
        height: 20px;
        color: var(--color-text-secondary);
      }
      .focus-mode-off .icon-shrink,
      .focus-mode-on .icon-expand {
        display: none;
      }

      h1.main-title {
        color: var(--color-primary);
        margin-bottom: 20px;
      }

      /* 非表示になるコントロールパネルの共通スタイル */
      .control-panel {
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .focus-mode-on .control-panel {
        opacity: 0;
        transform: translateY(-15px);
        height: 0;
        overflow: hidden;
        margin-top: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
      }
      .focus-mode-on h1.main-title {
        opacity: 0;
        height: 0;
        overflow: hidden;
        margin-bottom: 0;
      }

      /* ゲームエリア */
      .game-area {
        min-height: 280px;
        position: relative;
        margin-bottom: 20px;
        transition: min-height 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .focus-mode-on .game-area {
        min-height: 450px;
        margin-top: 40px;
      }

      .focus-mode-on #result-display {
        transform: scale(1.2);
      }

      /* ルーレットモード */
      .roulette-container {
        transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .roulette-wheel {
        transition: transform 5s cubic-bezier(0.1, 0.8, 0.2, 1);
      }
      .focus-mode-on .roulette-container {
        transform: scale(1.4);
      }

      /* カード選択モード */
      .focus-mode-on .card-grid {
        gap: 15px;
      }
      .focus-mode-on .card {
        height: 100px;
      }

      /* 履歴エリア */
      .history-area {
        margin-top: 20px;
      }

      /* モード選択 */
      .mode-selector {
        position: relative;
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
        border: 1px solid var(--color-border);
        border-radius: var(--radius);
        overflow: hidden;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      .mode-highlight {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        background-color: var(--color-primary-light);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 0;
      }
      .mode-btn {
        position: relative;
        z-index: 1;
        flex: 1;
        padding: 10px;
        border: none;
        background-color: transparent;
        cursor: pointer;
        font-size: 0.9rem;
        color: var(--color-text-secondary);
        transition: color 0.3s;
      }
      .mode-btn.active {
        font-weight: bold;
      }

      /* 設定・オプション */
      .settings,
      .options {
        margin-bottom: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
      }
      input[type="number"] {
        width: 60px;
        padding: 8px;
        border: 1px solid var(--color-border);
        border-radius: var(--radius);
        text-align: center;
        font-size: 1rem;
      }
      input[type="checkbox"] {
        transform: scale(1.2);
        margin-right: 5px;
      }

      /* ボタン */
      .buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-bottom: 25px;
      }
      button {
        padding: 20px 35px;
        font-size: 1.1rem;
        font-weight: bold;
        border: none;
        border-radius: var(--radius);
        cursor: pointer;
        transition: background-color 0.3s, transform 0.1s;
      }
      #start-button {
        background-color: var(--color-primary);
        color: var(--color-white);
      }
      #start-button:hover {
        background-color: var(--color-primary-dark);
      }
      #start-button:disabled {
        background-color: var(--color-primary-disabled);
        cursor: not-allowed;
      }
      #reset-button {
        background-color: var(--color-bg-secondary);
        color: var(--color-text-primary);
      }
      #reset-button:hover {
        background-color: var(--color-bg-secondary-hover);
      }
      button:active {
        transform: scale(0.9);
      }

      .mode-content {
        position: absolute;
        width: 100%;
        top: 0;
        left: 0;
        opacity: 0;
        transform: translateX(15px);
        pointer-events: none;
        transition: opacity 0.4s ease, transform 0.4s ease;
      }
      .mode-content.active {
        opacity: 1;
        transform: translateX(0);
        pointer-events: auto;
      }

      /* シンプルモード */
      #simple-mode-area {
        padding: 20px;
        border-radius: 10px;
        box-sizing: border-box;
      }
      #simple-mode-area p {
        margin: 0 0 10px 0;
        font-size: 1rem;
        color: var(--color-text-secondary);
      }
      .result-box {
        font-size: 5rem;
        font-weight: bold;
        color: var(--color-primary);
        min-height: 80px;
        line-height: 80px;
      }
      .zoom {
        animation: result-reveal-animation 0.8s
          cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      }

      @keyframes result-reveal-animation {
        0% {
          transform: translateY(20px) scale(0.8);
          opacity: 0;
        }
        50% {
          transform: translateY(-10px) scale(1.1);
          opacity: 1;
        }
        100% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
      }

      /* ルーレットモード */
      .roulette-container {
        position: relative;
        width: 280px;
        height: 280px;
        margin: 0 auto;
      }

      .focus-mode-on .roulette-container {
        width: 400px;
        height: 400px;
      }

      .roulette-pointer {
        position: absolute;
        top: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 15px solid transparent;
        border-right: 15px solid transparent;
        border-top: 30px solid var(--color-accent);
        z-index: 10;
      }
      .roulette-wheel {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 5px solid var(--color-neutral-dark);
        position: relative;
        transition: transform 5s cubic-bezier(0.1, 0.8, 0.2, 1);
        overflow: hidden;
      }
      .roulette-wheel .number {
        position: absolute;
        top: 50%;
        left: 50%;
        transform-origin: center left;
        width: 100px;
        height: 1px;
        display: flex;
        justify-content: flex-end;
        align-items: center;
      }
      .roulette-wheel .number span {
        display: block;
        transform: rotate(90deg);
        font-weight: bold;
        font-size: 1rem;
        color: var(--color-text-primary);
        padding: 3px 8px;
        background-color: var(--roulette-number-bg);
        border-radius: 5px;
        transition: opacity 0.3s ease;
      }

      .roulette-wheel .number.drawn span {
        opacity: 0.2;
      }

      .focus-mode-on .roulette-wheel .number {
        width: 185px;
      }

      .focus-mode-on .roulette-wheel .number span {
        background-color: transparent;
        color: var(--color-white);
        /* font-size: 1.1rem; ← JSで上書きされるためコメントアウト的扱いになります */
        text-shadow: 0 0 4px rgba(0, 0, 0, 0.6);
      }

      /* カード選択モード */
      #card-message {
        margin-top: 10px;
        color: var(--color-text-secondary);
        min-height: 24px;
      }
      .card-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
        gap: 10px;
        padding: 10px;
        max-height: 240px;
        overflow-y: auto;
      }
      .card {
        height: 60px;
        background-color: var(--color-card);
        border-radius: 8px;
        cursor: pointer;
        perspective: 1000px;
      }
      .card.flipped {
        pointer-events: none;
      }
      .card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        text-align: center;
        transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        transform-style: preserve-3d;
      }

      .card.flipped .card-inner {
        transform: rotateY(180deg);
      }
      .card-front,
      .card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 6px;
      }
      .card-front {
        background-color: var(--color-card);
        color: var(--color-white);
        font-size: 2rem;
        font-weight: bold;
      }
      .card-front::before {
        content: "?";
      }
      .card-back {
        background-color: var(--color-card-back);
        color: var(--color-text-primary);
        transform: rotateY(180deg);
        font-size: 1.8rem;
        font-weight: bold;
      }

      /* 履歴エリア */
      #history-list {
        list-style: none;
        padding: 0;
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
        max-height: 120px;
        overflow-y: auto;
        background-color: var(--color-bg-alt);
        border: 1px solid var(--color-border);
        border-radius: 20px;
        padding: 30px;
      }
      #history-list li {
        background-color: var(--color-white);
        color: var(--color-text-secondary);
        padding: 5px 12px;
        border-radius: 15px;
        border: 1px solid var(--color-border-light);
        font-size: 0.9rem;
      }

      /* 結果表示オーバーレイ */
      #result-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--overlay-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.4s ease-in-out;
        pointer-events: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      #result-overlay:not(.hidden) {
        opacity: 1;
        pointer-events: auto;
      }
      #result-popup {
        font-size: 10rem;
        font-weight: bold;
        color: var(--color-white);
        padding: 40px 60px;
        background-color: var(--color-primary);
        border-radius: 20px;
        transform: scale(0.7) translateY(20px);
        opacity: 0;
        transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1),
          opacity 0.3s ease;
      }
      #result-overlay:not(.hidden) #result-popup {
        transform: scale(1) translateY(0);
        opacity: 1;
      }

      /* レスポンシブ対応 */
      @media (max-width: 480px) {
        .container {
          padding: 20px;
        }
        h1 {
          font-size: 1.8rem;
        }
        .buttons {
          flex-direction: column;
        }
        #result-popup {
          font-size: 6rem;
        }
      }

      /* 設定モーダル */
      #settings-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--overlay-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1100;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
        pointer-events: none;
      }
      #settings-modal:not(.hidden) {
        opacity: 1;
        pointer-events: auto;
      }
      .modal-content {
        background-color: var(--color-white);
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 8px 25px var(--shadow-color-medium);
        width: 90%;
        max-width: 728px;
        position: relative;
        transform: scale(0.9);
        transition: transform 0.3s ease;
        max-height: 95vh; /* 画面が小さいときにはみ出さないように */
        overflow-y: auto; /* スクロール可能に */
      }
      .adbox {
        text-align: center;
        padding-bottom: 20px;
      }

      .ad-text {
        font-size: 0.8rem;
        color: var(--color-text-secondary);
      }
      #close-ad-btn {
        margin-bottom: 10px;
        padding: 8px 16px;
        font-size: 0.9rem;
        background-color: var(--color-bg-secondary);
        border: none;
        border-radius: var(--radius);
        cursor: pointer;
        transition: background-color 0.3s, transform 0.1s;
        display: block;
        margin-left: auto;
        margin-right: 0;
      }

      .hidden.adbox {
        display: none !important;
      }
      #settings-modal:not(.hidden) .modal-content {
        transform: scale(1);
      }
      .close-btn {
        position: absolute;
        top: 10px;
        right: 15px;
        font-size: 2rem;
        color: var(--color-text-secondary);
        background: none;
        border: none;
        cursor: pointer;
        padding: 0;
        line-height: 1;
      }
      .setting-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 20px;
      }
      .setting-item label {
        font-size: 1rem;
      }
      #volume-slider {
        width: 60%;
      }

      /* プロファイルセクション */
      .profiles-section {
        margin-top: 20px;
      }
      .profiles-section h3 {
        margin-bottom: 15px;
        color: var(--color-text-primary);
        text-align: left;
      }
      #profiles-container {
        display: flex; /* 横並びに */
        flex-wrap: wrap; /* 折り返し */
        gap: 10px; /* アイテム間の隙間 */
      }
      .profile-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        background-color: var(--color-bg-alt);
        border: 1px solid var(--color-border);
        border-radius: var(--radius);
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .profile-item.active {
        background-color: var(--color-primary-light);
        border-color: var(--color-primary);
        font-weight: bold;
      }
      .profile-item:hover:not(.active) {
        background-color: var(--color-bg-secondary);
      }
      .profile-item .profile-name {
        flex-grow: 1;
      }

      /* プロファイル操作ボタンの共通スタイル */
      .profile-item .delete-profile-btn,
      .profile-item .export-profile-btn {
        background: none;
        border: none;
        color: var(--color-text-secondary);
        cursor: pointer;
        padding: 2px;
        font-size: 1rem;
        line-height: 1;
        opacity: 0.5;
        transition: opacity 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .profile-item:hover .delete-profile-btn,
      .profile-item:hover .export-profile-btn {
        opacity: 1;
      }
      .profile-item .export-profile-btn svg {
        width: 18px;
        height: 18px;
        fill: currentColor;
      }

      #add-profile-btn {
        padding: 8px 12px;
        font-size: 0.9rem;
        background-color: var(--color-bg-secondary);
        border: 1px dashed var(--color-border);
        color: var(--color-text-secondary);
      }
      #add-profile-btn:hover {
        background-color: var(--color-bg-secondary-hover);
      }

      /* プロファイル用カスタムコンテキストメニュー */
      #profile-context-menu {
        position: fixed;
        z-index: 1200;
        background-color: var(--color-white);
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        padding: 8px 0;
        min-width: 150px;
        opacity: 0;
        transform: scale(0.95);
        transform-origin: top left;
        transition: opacity 0.15s ease, transform 0.15s ease;
        pointer-events: none;
      }

      #profile-context-menu.visible {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
      }

      .context-menu-item {
        padding: 10px 20px;
        cursor: pointer;
        font-size: 0.9rem;
        color: var(--color-text-primary);
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .context-menu-item:hover {
        background-color: var(--color-primary-light);
        color: var(--color-primary);
      }

      .context-menu-separator {
        height: 1px;
        background-color: var(--color-border);
        margin: 5px 0;
      }

      .focus-mode-on #roulette-mode-area {
        margin-top: 120px;
      }

      .focus-mode-on #result-display {
        padding-top: 200px;
        font-size: 20rem;
      }

      body {
        overflow: hidden;
      }

      #names-list,
      #exclude-numbers,
      #history-list {
        border-radius: 20px !important;
      }
      #reset-local-storage-btn {
        background-color: var(--color-bg-secondary);
        color: var(--color-text-primary);
        padding: 10px 20px;
        border: none;
        border-radius: var(--radius);
        cursor: pointer;
        font-size: 1rem;
        transition: background-color 0.3s, transform 0.1s;
      }

      /* インポートボタン用スタイル */
      #import-profile-btn {
        background-color: var(--color-primary-light);
        color: var(--color-primary);
        padding: 10px 0px;
        border: none;
        border-radius: var(--radius);
        cursor: pointer;
        font-size: 1rem;
        margin-left: 10px;
        transition: background-color 0.3s, transform 0.1s;
      }
      /* #import-profile-btn:hover {
        background-color: var(--color-primary-disabled);
      } */

      .github-open-button {
        padding-left: 15px;
        color: var(--color-primary);
        text-decoration: none;
      }

      #open-in-new-tab-icon {
        color: var(--color-primary);
        fill: var(--color-primary);
      }

      /* ★★★ 新着情報セクションのスタイル ★★★ */
      .news-section {
        margin-top: 25px;
        text-align: left;
      }
      .news-section h3 {
        margin-bottom: 10px;
        font-size: 1.1rem;
        color: var(--color-text-primary);
      }
      .news-item {
        border: 1px solid var(--color-border);
        border-radius: 12px;
        padding: 15px;
        background-color: var(--color-bg-alt);
        margin-bottom: 10px;
      }
      .news-header {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        flex-wrap: wrap;
        gap: 10px;
      }
      .news-version {
        font-weight: bold;
        color: var(--color-white);
        background-color: var(--color-primary);
        padding: 3px 8px;
        border-radius: 6px;
        font-size: 0.8rem;
      }
      .news-title {
        font-weight: bold;
        font-size: 1rem;
        color: var(--color-text-primary);
      }
      .news-detail {
        font-size: 0.9rem;
        color: var(--color-text-secondary);
        line-height: 1.5;
        margin-left: 2px;
      }

      /* Timer Display Styles */
      .timer-display {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 10em;
        font-weight: bold;
        color: var(--color-primary);
        z-index: 1000;
        text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.3);
      }

      .result-timer-display {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 2em;
        font-weight: bold;
        color: white;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        z-index: 1001;
      }

      /* Timer Mode Specific Styles */
      #timer-mode-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }

      .timer-input-group {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .timer-input-group input[type="number"] {
        width: 80px;
        padding: 10px;
        font-size: 1.5em;
        text-align: center;
        border: 2px solid var(--color-primary);
        border-radius: 5px;
      }

      .timer-input-group span {
        font-size: 1.5em;
        font-weight: bold;
      }

      .timer-display-mode {
        font-size: 5em;
        font-weight: bold;
        color: var(--color-primary);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }

      .timer-controls {
        display: flex;
        gap: 10px;
      }
    </style>
    <link rel="icon" href="https://daihachi10.github.io/assets/favicon.ico" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Caveat:wght@400..700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body class="focus-mode-off">
    <a href="https://daihachi10.github.io" class="home"
      ><span id="copy">&copy;</span>Daihachi</a
    >
    <div class="container">
      <div class="top-right-buttons">
        <span id="profile-name-display" class="profile-name-display"></span>
        <button
          id="theme-toggle-btn"
          class="focus-toggle-btn"
          title="テーマカラー切り替え"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 -960 960 960"
            fill="currentColor"
          >
            <path
              d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"
            />
          </svg>
        </button>
        <button id="settings-btn" class="focus-toggle-btn" title="設定">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 -960 960 960"
            fill="currentColor"
          >
            <path
              d="M200-160v-280h-80v-80h240v80h-80v280h-80Zm0-440v-200h80v200h-80Zm160 0v-80h80v-120h80v120h80v80H360Zm80 440v-360h80v360h-80Zm240 0v-120h-80v-80h240v80h-80v120h-80Zm0-280v-360h80v360h-80Z"
            />
          </svg>
        </button>
        <button
          id="focus-toggle-btn"
          class="focus-toggle-btn"
          title="フォーカスモード切り替え"
        >
          <svg
            class="icon-expand"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 -960 960 960"
            fill="currentColor"
          >
            <path
              d="M120-120v-200h80v120h120v80H120Zm520 0v-80h120v-120h80v200H640ZM120-640v-200h200v80H200v120h-80Zm640 0v-120H640v-80h200v200h-80Z"
            />
          </svg>
          <svg
            class="icon-shrink"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 -960 960 960"
          >
            <path
              d="M120-120v-200h80v120h120v80H120Zm520 0v-80h120v-120h80v200H640ZM120-640v-200h200v80H200v120h-80Zm640 0v-120H640v-80h200v200h-80Z"
            />
          </svg>
        </button>
      </div>

      <h1 class="main-title">ルーレット</h1>

      <!-- モード選択タブ -->
      <div class="mode-selector control-panel">
        <div class="mode-highlight"></div>
        <button class="mode-btn active" data-mode="simple">シンプル</button>
        <button class="mode-btn" data-mode="roulette">ルーレット</button>
        <button class="mode-btn" data-mode="card">カード選択</button>
      </div>

      <!-- 設定エリア -->
      <div class="settings control-panel"></div>
      <div class="buttons">
        <button id="start-button">スタート！</button>
        <button id="reset-button">リセット</button>
      </div>

      <!-- 各モードの表示エリア -->
      <div class="game-area">
        <!-- シンプルモード -->
        <div id="simple-mode-area" class="mode-content active">
          <p>結果は...</p>
          <div id="result-display" class="result-box">?</div>
        </div>

        <!-- ルーレットモード -->
        <div id="roulette-mode-area" class="mode-content">
          <div class="roulette-container">
            <div class="roulette-pointer"></div>
            <div class="roulette-wheel">
              <!-- JSで数字がここに生成されます -->
            </div>
          </div>
        </div>

        <!-- カード選択モード -->
        <div id="card-mode-area" class="mode-content">
          <p id="card-message">スタートボタンを押してカードを準備</p>
          <div class="card-grid">
            <!-- JSでカードがここに生成されます -->
          </div>
        </div>

        <!-- タイマーモード -->
        <div id="timer-mode-area" class="mode-content">
          <div class="timer-input-group">
            <input
              type="number"
              id="timer-minutes"
              value="0"
              min="0"
              max="59"
            />
            <span>:</span>
            <input
              type="number"
              id="timer-seconds"
              value="0"
              min="0"
              max="59"
            />
          </div>
          <div id="timer-display-mode" class="timer-display-mode">00:00</div>
          <div class="timer-controls">
            <button id="timer-start-btn">スタート</button>
            <button id="timer-pause-btn">一時停止</button>
            <button id="timer-reset-btn">リセット</button>
          </div>
        </div>
      </div>

      <div class="history-area control-panel">
        <ul id="history-list">
          <!-- ここに引いた数字の履歴が追加されます -->
        </ul>
      </div>
    </div>

    <!-- 結果表示用オーバーレイ -->
    <div id="result-overlay" class="hidden">
      <div id="result-popup"></div>
      <div id="result-timer-display" class="result-timer-display"></div>
    </div>

    <!-- 設定モーダル -->
    <div id="settings-modal" class="hidden">
      <div class="modal-content">
        <button id="close-modal-btn" class="close-btn">&times;</button>
        <h2>設定</h2>
        <div class="setting-item">
          <label for="volume-slider">効果音の音量</label>
          <input
            type="range"
            id="volume-slider"
            min="0"
            max="1"
            step="0.1"
            value="0.4"
          />
        </div>

        <hr />

        <!-- モード切り替えスイッチ -->
        <div style="margin-bottom: 15px">
          <label style="cursor: pointer; font-weight: bold; font-size: 1.1rem">
            <input type="checkbox" id="use-names-checkbox" />
            名前でルーレットする
          </label>
        </div>

        <!-- 数値モード用設定エリア (IDを追加してグループ化) -->
        <div id="number-settings-container">
          <div style="margin-bottom: 15px">
            <label for="min-number">範囲:</label>
            <input type="number" id="min-number" value="1" />
            <span>～</span>
            <input type="number" id="max-number" value="35" />
          </div>

          <div>
            <label
              for="exclude-numbers"
              style="display: block; margin-bottom: 5px"
              >除外する番号 (カンマ区切り):</label
            >
            <input
              type="text"
              id="exclude-numbers"
              placeholder="例: 4, 15, 22"
              style="
                width: 95%;
                padding: 8px;
                border-radius: 5px;
                border: 1px solid var(--color-border);
              "
            />
          </div>
        </div>

        <!-- 名前モード用設定エリア (IDを追加してグループ化) -->
        <div id="name-settings-container" style="display: none">
          <textarea
            id="names-list"
            placeholder="名前を改行区切りで入力してください。"
            style="
              width: 95%;
              height: 120px;
              padding: 8px;
              border-radius: 5px;
              border: 1px solid var(--color-border);
              margin-top: 5px;
            "
          ></textarea>
        </div>

        <div class="options control-panel" style="margin-top: 20px">
          <input type="checkbox" id="no-duplicates" checked />
          <label for="no-duplicates">一度引いた数字(または名前)は出ない</label>
        </div>
        <hr />

        <div class="profiles-section">
          <h3>プロファイル</h3>

          <div id="profiles-container">
            <!-- プロファイルがここにJSで生成されます -->
          </div>
        </div>
        <div>
          <!-- <button id="reset-local-storage-btn">
            ローカルに保存した設定をリセット
          </button> -->
          <!-- インポートボタンと隠しファイル入力 -->
          <button id="import-profile-btn">インポート</button>
          <input
            type="file"
            id="import-file-input"
            accept=".txt"
            style="display: none"
          />
        </div>
        <hr />

        <a
          href="https://github.com/daihachi10/daihachi10.github.io/tree/main/program/41"
          class="github-open-button"
          target="_blank"
          >Githubで開く<svg
            id="open-in-new-tab-icon"
            xmlns="http://www.w3.org/2000/svg"
            height="16px"
            viewBox="0 -960 960 960"
            width="16px"
          >
            <path
              d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h560v-280h80v280q0 33-23.5 56.5T760-120H200Zm188-212-56-56 372-372H560v-80h280v280h-80v-144L388-332Z"
            /></svg
        ></a>
        <hr />
        <!-- ★★★ 新着情報セクション ★★★ -->
        <div class="news-section">
          <h3>新着情報</h3>
          <div class="news-item">
            <div class="news-header">
              <span class="news-version">V1.2</span>
              <span class="news-title">プロファイルの保存機能強化</span>
            </div>
            <div class="news-detail">
              名前リストが保存されるようになり、プロファイルのインポート・エクスポート機能を追加しました。
            </div>
          </div>
        </div>

        <div class="adbox" id="adbox">
          <hr />
          <span class="ad-text">広告</span>
          <button id="close-ad-btn">×</button>
          <!-- admax -->
          <div
            class="admax-ads"
            data-admax-id="cfc35a98056c136d0b6a6ea4ced854dc"
            style="display: inline-block; width: 728px; height: 90px"
          ></div>
          <script type="text/javascript">
            (admaxads = window.admaxads || []).push({
              admax_id: "cfc35a98056c136d0b6a6ea4ced854dc",
              type: "banner",
            });
          </script>
          <script
            type="text/javascript"
            charset="utf-8"
            src="https://adm.shinobi.jp/st/t.js"
            async
          ></script>
          <!-- admax -->
        </div>
      </div>
    </div>

    <!-- プロファイル用カスタムコンテキストメニュー -->
    <div id="profile-context-menu">
      <div class="context-menu-item" data-action="load">読み込み</div>
      <div class="context-menu-item" data-action="save">現在の設定を保存</div>
      <!-- エクスポートメニューを追加 -->
      <div class="context-menu-item" data-action="export">エクスポート</div>
      <div class="context-menu-item" data-action="rename">名前の変更</div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // HTML要素の取得
        const body = document.body;
        const themeToggleButton = document.getElementById("theme-toggle-btn");
        const focusToggleButton = document.getElementById("focus-toggle-btn");
        const minNumInput = document.getElementById("min-number");
        const maxNumInput = document.getElementById("max-number");
        const excludeNumbersInput = document.getElementById("exclude-numbers");
        const noDuplicatesCheckbox = document.getElementById("no-duplicates");
        const startButton = document.getElementById("start-button");
        const resetButton = document.getElementById("reset-button");
        const historyList = document.getElementById("history-list");
        /* const resetLocalStorageBtn = document.getElementById(
          "reset-local-storage-btn"
        ); */

        // --- 新しく追加した要素 ---
        const useNamesCheckbox = document.getElementById("use-names-checkbox");
        const namesListInput = document.getElementById("names-list");
        const numberSettingsContainer = document.getElementById(
          "number-settings-container"
        );
        const nameSettingsContainer = document.getElementById(
          "name-settings-container"
        );

        // インポート関連の要素
        const importProfileBtn = document.getElementById("import-profile-btn");
        const importFileInput = document.getElementById("import-file-input");

        // モード関連の要素
        const modeSelector = document.querySelector(".mode-selector");
        const modeHighlight = document.querySelector(".mode-highlight");
        const modeButtons = document.querySelectorAll(".mode-btn");
        const modeContents = document.querySelectorAll(".mode-content");
        const resultDisplay = document.getElementById("result-display");
        const rouletteWheel = document.querySelector(".roulette-wheel");
        const cardGrid = document.querySelector(".card-grid");
        const cardMessage = document.getElementById("card-message");
        const resultOverlay = document.getElementById("result-overlay");
        const resultPopup = document.getElementById("result-popup");
        const resultTimerDisplay = document.getElementById(
          "result-timer-display"
        );

        // タイマーモード関連の要素
        const timerMinutesInput = document.getElementById("timer-minutes");
        const timerSecondsInput = document.getElementById("timer-seconds");
        const timerDisplayMode = document.getElementById("timer-display-mode");
        const timerStartBtn = document.getElementById("timer-start-btn");
        const timerPauseBtn = document.getElementById("timer-pause-btn");
        const timerResetBtn = document.getElementById("timer-reset-btn");

        // 設定モーダル関連の要素
        const settingsBtn = document.getElementById("settings-btn");
        const settingsModal = document.getElementById("settings-modal");
        const closeModalBtn = document.getElementById("close-modal-btn");
        const volumeSlider = document.getElementById("volume-slider");

        // プロファイル関連の要素
        const profilesContainer = document.getElementById("profiles-container");
        const contextMenu = document.getElementById("profile-context-menu");

        // ad
        const adCloseBtn = document.getElementById("close-ad-btn");
        const adBanner = document.getElementById("adbox");

        adCloseBtn.addEventListener("click", () => {
          adBanner.classList.add("hidden");
        });

        // --- 設定画面の表示切り替えロジック ---
        const toggleSettingsDisplay = () => {
          if (useNamesCheckbox.checked) {
            // 名前モードON: 数値設定を隠し、名前入力エリアを表示
            numberSettingsContainer.style.display = "none";
            nameSettingsContainer.style.display = "block";
          } else {
            // 名前モードOFF: 数値設定を表示し、名前入力エリアを隠す
            numberSettingsContainer.style.display = "block";
            nameSettingsContainer.style.display = "none";
          }
        };

        // --- 状態管理 ---
        let profiles = [];
        let activeProfileId = null;
        let contextMenuVisible = false;
        let contextTargetProfileId = null;

        // 音声関連のセットアップ
        const sounds = {
          simpleTick: new Audio("./sounds/simple_tick.mp3"),
          simpleResult: new Audio("./sounds/simple_result.mp3"),
          rouletteTick: new Audio("./sounds/roulette_tick.mp3"),
          rouletteResult: new Audio("./sounds/roulette_result.mp3"),
          cardFlip: new Audio("./sounds/card_flip.mp3"),
        };

        Object.values(sounds).forEach((sound) => {
          sound.volume = 0.4;
        });
        /*
        resetLocalStorageBtn.addEventListener("click", () => {
          if (confirm("本当にすべての設定とプロファイルをリセットしますか？")) {
            localStorage.clear();
            window.location.reload();
          }
        });
        */
        // インポート機能の実装
        importProfileBtn.addEventListener("click", () => {
          importFileInput.click();
        });

        importFileInput.addEventListener("change", (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const importedData = JSON.parse(event.target.result);

              // データの簡易バリデーション (必須フィールドがあるか)
              if (!importedData.name) {
                alert("無効なプロファイルデータです。");
                return;
              }

              // 新しいIDを生成して追加
              const newProfile = {
                ...importedData,
                id: Date.now(), // IDの衝突を防ぐため新規生成
              };

              // 同じ名前がある場合は (インポート) を付与
              let baseName = newProfile.name;
              let counter = 1;
              while (profiles.some((p) => p.name === newProfile.name)) {
                newProfile.name = `${baseName} (インポート ${counter})`;
                counter++;
              }

              profiles.push(newProfile);
              activeProfileId = newProfile.id;
              saveProfiles();
              renderProfiles();
              switchProfile(newProfile.id);
              alert(`プロファイル「${newProfile.name}」をインポートしました。`);
            } catch (error) {
              console.error(error);
              alert(
                "ファイルの読み込みに失敗しました。正しい形式のファイルか確認してください。"
              );
            }
            // inputの値をリセットして同じファイルを再選択できるようにする
            importFileInput.value = "";
          };
          reader.readAsText(file);
        });

        // --- 設定モーダルの処理 ---
        settingsBtn.addEventListener("click", () => {
          settingsModal.classList.remove("hidden");
        });

        closeModalBtn.addEventListener("click", () => {
          settingsModal.classList.add("hidden");
        });

        settingsModal.addEventListener("click", (e) => {
          if (e.target === settingsModal) {
            settingsModal.classList.add("hidden");
          }
        });

        volumeSlider.addEventListener("input", (e) => {
          const newVolume = parseFloat(e.target.value);
          Object.values(sounds).forEach((sound) => {
            sound.volume = newVolume;
          });
        });

        // --- プロファイル処理 ---
        const MAX_PROFILES = 5;

        const saveProfiles = () => {
          localStorage.setItem("rouletteProfiles", JSON.stringify(profiles));
          localStorage.setItem("activeProfileId", activeProfileId);
        };

        const loadProfiles = () => {
          const savedProfiles = localStorage.getItem("rouletteProfiles");
          const savedActiveId = localStorage.getItem("activeProfileId");
          if (savedProfiles) {
            profiles = JSON.parse(savedProfiles);
            activeProfileId = savedActiveId
              ? parseInt(savedActiveId)
              : profiles.length > 0
              ? profiles[0].id
              : null;
          } else {
            // デフォルトプロファイル
            profiles = [
              {
                id: 1,
                name: "デフォルト",
                min: 1,
                max: 35,
                exclude: "",
                useNames: false,
                names: "",
              },
            ];
            activeProfileId = 1;
          }
          const activeProfile = profiles.find((p) => p.id === activeProfileId);
          if (activeProfile) {
            minNumInput.value = activeProfile.min;
            maxNumInput.value = activeProfile.max;
            excludeNumbersInput.value = activeProfile.exclude || "";
            // プロファイルから名前設定を読み込み
            useNamesCheckbox.checked = activeProfile.useNames === true;
            namesListInput.value = activeProfile.names || "";
          }
          toggleSettingsDisplay(); // 表示状態を更新
          renderProfiles();
        };

        // プロファイルエクスポート関数
        const exportProfile = (profile) => {
          // JSONデータを作成
          const exportData = JSON.stringify(profile, null, 2);
          const blob = new Blob([exportData], { type: "text/plain" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${profile.name}.txt`; // ファイル名はプロファイル名.txt
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        };

        const renderProfiles = () => {
          profilesContainer.innerHTML = "";
          profiles.forEach((profile) => {
            const profileEl = document.createElement("div");
            profileEl.className = `profile-item ${
              profile.id === activeProfileId ? "active" : ""
            }`;
            profileEl.dataset.id = profile.id;
            // SVGアイコン入りのダウンロードボタンを追加
            profileEl.innerHTML = `
        <span class="profile-name">${profile.name}</span>
        <button class="export-profile-btn" title="エクスポート" data-id="${profile.id}">
           <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M160-80v-80h640v80H160Zm320-160L200-600h160v-280h240v280h160L480-240Zm0-130 116-150h-76v-280h-80v280h-76l116 150Zm0-150Z"/></svg>
        </button>
        <button class="delete-profile-btn" data-id="${profile.id}">&times;</button>
      `;
            profileEl.addEventListener("click", () =>
              switchProfile(profile.id)
            );
            profileEl.addEventListener("contextmenu", (e) =>
              showContextMenu(e, profile.id)
            );

            // 削除ボタンのイベントリスナー
            profileEl
              .querySelector(".delete-profile-btn")
              .addEventListener("click", (e) => {
                e.stopPropagation(); // 親要素のクリックイベントを発火させない
                deleteProfile(profile.id);
              });

            // エクスポートボタンのイベントリスナー
            profileEl
              .querySelector(".export-profile-btn")
              .addEventListener("click", (e) => {
                e.stopPropagation();
                exportProfile(profile);
              });

            profilesContainer.appendChild(profileEl);
          });

          if (profiles.length < MAX_PROFILES) {
            const addBtn = document.createElement("button");
            addBtn.id = "add-profile-btn";
            addBtn.textContent = "+ 追加";
            addBtn.addEventListener("click", addProfile);
            profilesContainer.appendChild(addBtn);
          }
        };

        const addProfile = () => {
          const newName = prompt(
            "新しいプロファイル名を入力してください:",
            `プロファイル ${profiles.length + 1}`
          );
          if (newName && newName.trim() !== "") {
            const newProfile = {
              id: Date.now(), // ユニークなIDを生成
              name: newName.trim(),
              min: parseInt(minNumInput.value),
              max: parseInt(maxNumInput.value),
              exclude: excludeNumbersInput.value,
              useNames: useNamesCheckbox.checked, // 現在のチェック状態
              names: namesListInput.value, // 現在の名前リスト
            };
            profiles.push(newProfile);
            activeProfileId = newProfile.id;
            saveProfiles();
            renderProfiles();
            switchProfile(newProfile.id);
          }
        };

        const deleteProfile = (id) => {
          if (profiles.length <= 1) {
            alert("最後のプロファイルは削除できません。");
            return;
          }
          if (confirm("本当にこのプロファイルを削除しますか？")) {
            profiles = profiles.filter((p) => p.id !== id);
            if (activeProfileId === id) {
              activeProfileId = profiles.length > 0 ? profiles[0].id : null;
              if (activeProfileId) {
                switchProfile(activeProfileId);
              }
            }
            saveProfiles();
            renderProfiles();
          }
        };

        const switchProfile = (id) => {
          activeProfileId = id;
          const profile = profiles.find((p) => p.id === id);
          if (profile) {
            // プロファイルの値を入力フォームにセット
            minNumInput.value = profile.min;
            maxNumInput.value = profile.max;
            excludeNumbersInput.value = profile.exclude || "";
            // 名前設定も復元
            useNamesCheckbox.checked = profile.useNames === true;
            namesListInput.value = profile.names || "";

            toggleSettingsDisplay(); // UI切り替え
            saveProfiles();
            renderProfiles();
            resetButton.click(); // プロファイル切り替え時にリセット
          }
        };

        // プロファイル更新関数（入力イベントで発火）
        function updateActiveProfile() {
          const profile = profiles.find((p) => p.id === activeProfileId);
          if (profile) {
            profile.min = parseInt(minNumInput.value);
            profile.max = parseInt(maxNumInput.value);
            profile.exclude = excludeNumbersInput.value;
            // 名前設定も保存
            profile.useNames = useNamesCheckbox.checked;
            profile.names = namesListInput.value;
            saveProfiles();
          }
          // UIの切り替えも行う
          toggleSettingsDisplay();
        }

        // イベントリスナー
        minNumInput.addEventListener("change", updateActiveProfile);
        maxNumInput.addEventListener("change", updateActiveProfile);
        excludeNumbersInput.addEventListener("change", updateActiveProfile);

        // 名前モード切り替えと入力も即時保存
        useNamesCheckbox.addEventListener("change", updateActiveProfile);
        // テキストエリアは input イベントで即時反映
        namesListInput.addEventListener("input", updateActiveProfile);

        // 初期化
        loadProfiles();

        // --- コンテキストメニュー処理 ---
        const showContextMenu = (e, profileId) => {
          e.preventDefault();
          contextTargetProfileId = profileId;
          contextMenu.style.top = `${e.clientY}px`;
          contextMenu.style.left = `${e.clientX}px`;
          contextMenu.classList.add("visible");
          contextMenuVisible = true;
        };

        const hideContextMenu = () => {
          if (contextMenuVisible) {
            contextMenu.classList.remove("visible");
            contextMenuVisible = false;
          }
        };

        window.addEventListener("click", hideContextMenu);

        contextMenu.addEventListener("click", (e) => {
          const action = e.target.dataset.action;
          if (!action || !contextTargetProfileId) return;

          const profile = profiles.find((p) => p.id === contextTargetProfileId);
          if (!profile) return;

          switch (action) {
            case "load":
              switchProfile(contextTargetProfileId);
              break;
            case "save":
              // 現在の入力値をプロファイルに保存
              profile.min = parseInt(minNumInput.value);
              profile.max = parseInt(maxNumInput.value);
              profile.exclude = excludeNumbersInput.value;
              profile.useNames = useNamesCheckbox.checked;
              profile.names = namesListInput.value;
              saveProfiles();
              alert(
                `プロファイル「${profile.name}」に現在の設定を保存しました。`
              );
              break;
            case "export": // エクスポート機能
              exportProfile(profile);
              break;

            case "rename":
              const newName = prompt(
                "新しいプロファイル名を入力してください:",
                profile.name
              );
              if (newName && newName.trim() !== "") {
                profile.name = newName.trim();
                saveProfiles();
                renderProfiles();
              }
              break;
          }
          hideContextMenu();
        });

        const playSound = (sound) => {
          const audio = sound.cloneNode();
          audio.volume = sound.volume;
          audio
            .play()
            .catch((e) => console.error("音声の再生に失敗しました:", e));
        };

        const initAudio = () => {
          Object.values(sounds).forEach((sound) => {
            sound
              .play()
              .then(() => sound.pause())
              .catch(() => {});
          });
          document.body.removeEventListener("click", initAudio);
          document.body.removeEventListener("touchstart", initAudio);
        };
        document.body.addEventListener("click", initAudio, { once: true });
        document.body.addEventListener("touchstart", initAudio, { once: true });

        // 状態管理
        let currentMode = "simple";
        let drawnNumbers = [];
        let isSpinning = false;
        let rotationDegree = 0;
        let cardGameActive = false;
        let availableCards = [];
        let rouletteSpinTimeoutId = null;
        let currentRouletteResultNumber = null;
        let currentRouletteFinalTargetAngle = 0;
        let countdownInterval = null;

        // タイマーモード用の状態
        let timerModeInterval = null;
        let timerModeTimeLeft = 0;
        let timerModeIsRunning = false;

        // ルーレット音声用の状態管理
        let rouletteAudioContext = {
          loopId: null,
          lastAngle: 0,
          angleSinceLastTick: 0,
          segmentAngle: 0,
          lastTickTimestamp: 0,
          minTimeBetweenTicks: 100,
        };

        // --- テーマ切り替え処理 ---
        const themes = [
          { name: "Blue", color: "#1a73e8" },
          { name: "Pink", color: "#ff007b" },
          { name: "Green", color: "#1e8e3e" },
          { name: "Red", color: "#d93025" },
          { name: "Purple", color: "#8e44ad" },
          { name: "Orange", color: "#f0932b" },
        ];
        let currentThemeIndex = 0;

        const hexToHsl = (hex) => {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          let r = parseInt(result[1], 16) / 255;
          let g = parseInt(result[2], 16) / 255;
          let b = parseInt(result[3], 16) / 255;
          const max = Math.max(r, g, b),
            min = Math.min(r, g, b);
          let h,
            s,
            l = (max + min) / 2;
          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return { h: h * 360, s: s * 100, l: l * 100 };
        };

        const hslToHex = (h, s, l) => {
          s /= 100;
          l /= 100;
          const c = (1 - Math.abs(2 * l - 1)) * s;
          const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
          const m = l - c / 2;
          let r = 0,
            g = 0,
            b = 0;
          if (0 <= h && h < 60) {
            r = c;
            g = x;
            b = 0;
          } else if (60 <= h && h < 120) {
            r = x;
            g = c;
            b = 0;
          } else if (120 <= h && h < 180) {
            r = 0;
            g = c;
            b = x;
          } else if (180 <= h && h < 240) {
            r = 0;
            g = x;
            b = c;
          } else if (240 <= h && h < 300) {
            r = x;
            g = 0;
            b = c;
          } else if (300 <= h && h < 360) {
            r = c;
            g = 0;
            b = x;
          }
          r = Math.round((r + m) * 255)
            .toString(16)
            .padStart(2, "0");
          g = Math.round((g + m) * 255)
            .toString(16)
            .padStart(2, "0");
          b = Math.round((b + m) * 255)
            .toString(16)
            .padStart(2, "0");
          return `#${r}${g}${b}`;
        };

        const applyTheme = (color) => {
          const hsl = hexToHsl(color);
          const root = document.documentElement;
          root.style.setProperty("--color-primary", color);
          root.style.setProperty(
            "--color-primary-dark",
            hslToHex(hsl.h, hsl.s, hsl.l - 10)
          );
          root.style.setProperty(
            "--color-primary-light",
            hslToHex(hsl.h, hsl.s, hsl.l + 85)
          );
          root.style.setProperty(
            "--color-primary-disabled",
            hslToHex(hsl.h, hsl.s, hsl.l + 30)
          );
        };

        themeToggleButton.addEventListener("click", () => {
          currentThemeIndex = (currentThemeIndex + 1) % themes.length;
          applyTheme(themes[currentThemeIndex].color);
        });
        applyTheme(themes[currentThemeIndex].color);

        focusToggleButton.addEventListener("click", () => {
          body.classList.toggle("focus-mode-on");
          body.classList.toggle("focus-mode-off");
        });

        // --- 共通関数 ---
        const getAvailableNumbers = () => {
          // 名前モードが有効なら名前リストを返す
          if (useNamesCheckbox.checked) {
            const raw = namesListInput.value || "";
            // カンマまたは改行で分割してトリム、空白を除去
            const names = raw
              .split(/,|\n/)
              .map((s) => s.trim())
              .filter((s) => s !== "");
            // 一意化
            const uniqueNames = Array.from(new Set(names));
            // 重複なしが有効でかつ既に引かれているものは除外
            const available = uniqueNames.filter((name) => {
              if (noDuplicatesCheckbox.checked && drawnNumbers.includes(name)) {
                return false;
              }
              return true;
            });
            if (available.length === 0) {
              return [];
            }
            return available;
          }

          // 数値モード
          const min = parseInt(minNumInput.value);
          const max = parseInt(maxNumInput.value);
          if (isNaN(min) || isNaN(max) || min >= max) {
            alert("有効な範囲を正しく入力してください（最小値 < 最大値）。");
            return null;
          }

          const excludeString = excludeNumbersInput.value;
          const excludedNumbers = excludeString
            .split(",")
            .map((n) => parseInt(n.trim()))
            .filter((n) => !isNaN(n));

          const available = [];
          for (let i = min; i <= max; i++) {
            if (
              (!noDuplicatesCheckbox.checked || !drawnNumbers.includes(i)) &&
              !excludedNumbers.includes(i) // 除外リストチェック
            ) {
              available.push(i);
            }
          }
          return available;
        };

        const addToHistory = (number) => {
          drawnNumbers.push(number);
          const historyItem = document.createElement("li");
          historyItem.textContent = number;
          historyList.prepend(historyItem);
        };

        const showResultPopup = (number, duration = 1.5) => {
          resultPopup.textContent = number;
          resultOverlay.classList.remove("hidden");
          setTimeout(() => {
            resultOverlay.classList.add("hidden");
          }, duration * 1000);
        };

        const setControlsDisabled = (disabled) => {
          isSpinning = disabled;
          minNumInput.disabled = disabled;
          maxNumInput.disabled = disabled;
          excludeNumbersInput.disabled = disabled;
          noDuplicatesCheckbox.disabled = disabled;
          startButton.disabled = disabled;
          useNamesCheckbox.disabled = disabled;
          namesListInput.disabled = disabled;
        };

        // --- モード切り替え ---
        const setActiveMode = (mode) => {
          if (currentMode === mode) return;
          if (isSpinning && !cardGameActive) return;
          if (currentMode === "card" && cardGameActive) {
            cardGameActive = false;
            cardGrid.innerHTML = "";
            availableCards = [];
          }

          const gameButtons = document.querySelector(".buttons");
          if (mode === "timer") {
            gameButtons.style.display = "none";
            timerMinutesInput.value = 0;
            timerSecondsInput.value = 0;
            timerModeTimeLeft = 0;
            updateTimerDisplay();
            timerPauseBtn.disabled = true;
            timerResetBtn.disabled = true;
            timerMinutesInput.disabled = false;
            timerSecondsInput.disabled = false;
            timerStartBtn.textContent = "スタート";
            clearInterval(timerModeInterval);
            timerModeIsRunning = false;
          } else {
            gameButtons.style.display = "flex";
          }

          currentMode = mode;
          const activeButton = document.querySelector(
            `.mode-btn[data-mode="${mode}"]`
          );
          modeHighlight.style.width = `${activeButton.offsetWidth}px`;
          modeHighlight.style.transform = `translateX(${activeButton.offsetLeft}px)`;
          modeButtons.forEach((btn) => btn.classList.remove("active"));
          activeButton.classList.add("active");
          modeContents.forEach((content) => content.classList.remove("active"));
          document
            .getElementById(`${currentMode}-mode-area`)
            .classList.add("active");
          if (currentMode === "card") {
            const availableNumbers = getAvailableNumbers();
            if (availableNumbers && availableNumbers.length > 0) {
              startCardMode(availableNumbers);
            } else {
              cardMessage.textContent = "すべての数字を引き終えました！";
              setControlsDisabled(false);
            }
          } else {
            startButton.textContent = "スタート！";
            setControlsDisabled(false);
          }
        };

        modeButtons.forEach((btn) => {
          btn.addEventListener("click", () => setActiveMode(btn.dataset.mode));
        });

        let isDragging = false,
          startX,
          currentDragMode;
        const handleDragStart = (e) => {
          isDragging = true;
          startX = e.pageX || e.touches[0].pageX;
          currentDragMode = currentMode;
          modeSelector.style.cursor = "grabbing";
        };
        const handleDragMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const x = e.pageX || e.touches[0].pageX;
          const walk = x - startX;
          const buttonWidth = modeButtons[0].offsetWidth;
          const modeOrder = Array.from(modeButtons).map(
            (btn) => btn.dataset.mode
          );
          const currentIndex = modeOrder.indexOf(currentDragMode);
          if (walk > buttonWidth / 2 && currentIndex < modeOrder.length - 1) {
            setActiveMode(modeOrder[currentIndex + 1]);
            isDragging = false;
          } else if (walk < -buttonWidth / 2 && currentIndex > 0) {
            setActiveMode(modeOrder[currentIndex - 1]);
            isDragging = false;
          }
        };
        const handleDragEnd = () => {
          isDragging = false;
          modeSelector.style.cursor = "grab";
        };
        modeSelector.addEventListener("mousedown", handleDragStart);
        modeSelector.addEventListener("touchstart", handleDragStart);
        modeSelector.addEventListener("mousemove", handleDragMove);
        modeSelector.addEventListener("touchmove", handleDragMove);
        modeSelector.addEventListener("mouseup", handleDragEnd);
        modeSelector.addEventListener("touchend", handleDragEnd);
        modeSelector.addEventListener("mouseleave", handleDragEnd);

        window.addEventListener("load", () => {
          setTimeout(() => {
            const activeButton = document.querySelector(".mode-btn.active");
            if (activeButton) {
              modeHighlight.style.width = `${activeButton.offsetWidth}px`;
              modeHighlight.style.transform = `translateX(${activeButton.offsetLeft}px)`;
            }
          }, 50);
        });

        // ルーレット音声のループ処理
        const rouletteAudioTick = () => {
          if (!isSpinning) {
            stopRouletteAudio();
            return;
          }

          const transform = window.getComputedStyle(rouletteWheel).transform;
          if (transform !== "none") {
            const matrix = new DOMMatrix(transform);
            const currentAngle =
              Math.atan2(matrix.b, matrix.a) * (180 / Math.PI);

            let delta = currentAngle - rouletteAudioContext.lastAngle;
            if (delta < -270) {
              delta += 360;
            } else if (delta > 270) {
              delta -= 360;
            }

            rouletteAudioContext.angleSinceLastTick += Math.abs(delta);
            rouletteAudioContext.lastAngle = currentAngle;

            while (
              rouletteAudioContext.angleSinceLastTick >=
              rouletteAudioContext.segmentAngle
            ) {
              rouletteAudioContext.angleSinceLastTick -=
                rouletteAudioContext.segmentAngle;

              const now = Date.now();
              if (
                now - rouletteAudioContext.lastTickTimestamp >
                rouletteAudioContext.minTimeBetweenTicks
              ) {
                playSound(sounds.rouletteTick);
                rouletteAudioContext.lastTickTimestamp = now;
              }
            }
          }

          rouletteAudioContext.loopId =
            requestAnimationFrame(rouletteAudioTick);
        };

        const startRouletteAudio = (segmentAngle) => {
          stopRouletteAudio();

          const initialTransform =
            window.getComputedStyle(rouletteWheel).transform;
          const initialMatrix = new DOMMatrix(initialTransform);
          rouletteAudioContext = {
            ...rouletteAudioContext,
            loopId: null,
            lastAngle:
              Math.atan2(initialMatrix.b, initialMatrix.a) * (180 / Math.PI),
            angleSinceLastTick: 0,
            segmentAngle: segmentAngle,
            lastTickTimestamp: 0,
          };

          rouletteAudioContext.loopId =
            requestAnimationFrame(rouletteAudioTick);
        };

        const stopRouletteAudio = () => {
          if (rouletteAudioContext.loopId) {
            cancelAnimationFrame(rouletteAudioContext.loopId);
            rouletteAudioContext.loopId = null;
          }
        };

        // --- スタートボタン処理 ---
        startButton.addEventListener("click", () => {
          if (currentMode === "roulette" && isSpinning) {
            stopRouletteAudio();
            playSound(sounds.rouletteResult);

            clearTimeout(rouletteSpinTimeoutId);

            rouletteWheel.style.transition =
              "transform 1.5s cubic-bezier(0.2, 0.95, 0.3, 1)";
            rouletteWheel.style.transform = `rotate(${currentRouletteFinalTargetAngle}deg)`;

            setTimeout(() => {
              rouletteWheel.style.transition =
                "transform 5s cubic-bezier(0.1, 0.8, 0.2, 1)";
            }, 1500);

            showResultPopup(currentRouletteResultNumber, 3);
            addToHistory(currentRouletteResultNumber);
            setControlsDisabled(false);
            startButton.textContent = "スタート！";
            startButton.disabled = false;
            rouletteSpinTimeoutId = null;
            return;
          }

          if (isSpinning) return;
          const availableNumbers = getAvailableNumbers();
          if (!availableNumbers) return;
          if (availableNumbers.length === 0) {
            alert("すべての数字を引き終えました！リセットしてください。");
            return;
          }
          setControlsDisabled(true);
          body.classList.add("focus-mode-on");
          body.classList.remove("focus-mode-off");

          switch (currentMode) {
            case "simple":
              startSimpleMode(availableNumbers);
              break;
            case "roulette":
              startRouletteMode(availableNumbers);
              break;
            case "card":
              startCardMode(availableNumbers);
              break;
          }
        });

        // --- 各モードの実行関数 ---
        const startSimpleMode = (numbers) => {
          resultDisplay.classList.remove("zoom");
          void resultDisplay.offsetWidth;

          const spinInterval = setInterval(() => {
            resultDisplay.textContent =
              numbers[Math.floor(Math.random() * numbers.length)];
            playSound(sounds.simpleTick);
          }, 50);

          setTimeout(() => {
            clearInterval(spinInterval);
            const resultNumber =
              numbers[Math.floor(Math.random() * numbers.length)];
            resultDisplay.textContent = resultNumber;
            resultDisplay.classList.add("zoom");
            playSound(sounds.simpleResult);
            addToHistory(resultNumber);
            setControlsDisabled(false);
          }, 2000);
        };

        const startRouletteMode = (numbers) => {
          const totalNumbersOnWheel = numbers.length;
          const segmentAngle = 360 / totalNumbersOnWheel;

          const colors = [
            "#ffadad",
            "#ffd6a5",
            "#fdffb6",
            "#caffbf",
            "#9bf6ff",
            "#a0c4ff",
            "#bdb2ff",
            "#ffc6ff",
          ];
          const gradientStartAngle = 270 - segmentAngle / 2;
          let gradient = `conic-gradient(from ${gradientStartAngle}deg, `;
          rouletteWheel.innerHTML = "";

          for (let i = 0; i < totalNumbersOnWheel; i++) {
            const label = numbers[i];
            gradient += `${colors[i % colors.length]} ${i * segmentAngle}deg ${
              (i + 1) * segmentAngle
            }deg`;
            if (i < totalNumbersOnWheel - 1) gradient += ", ";

            const numberDiv = document.createElement("div");
            numberDiv.className = "number";
            numberDiv.style.transform = `rotate(${
              i * segmentAngle + segmentAngle / 2
            }deg)`;

            if (noDuplicatesCheckbox.checked && drawnNumbers.includes(label)) {
              numberDiv.classList.add("drawn");
            }

            const span = document.createElement("span");
            span.textContent = label;

            // ★★★ 文字数に応じてフォントサイズを調整 ★★★
            const length = String(label).length;
            if (length > 10) {
              span.style.fontSize = "0.5rem";
            } else if (length > 7) {
              span.style.fontSize = "0.7rem";
            } else if (length > 5) {
              span.style.fontSize = "0.85rem";
            } else {
              span.style.fontSize = "1.1rem"; // デフォルト（短い文字用）
            }
            // 長い名前が改行されないようにする
            span.style.whiteSpace = "nowrap";

            numberDiv.appendChild(span);
            rouletteWheel.appendChild(numberDiv);
          }
          gradient += ")";
          rouletteWheel.style.background = gradient;

          const currentAngle = ((rotationDegree % 360) + 360) % 360;
          const resultNumber =
            numbers[Math.floor(Math.random() * numbers.length)];
          const resultIndexOnWheel = numbers.indexOf(resultNumber);

          const randomOffset = (Math.random() - 0.5) * segmentAngle * 0.75;
          const targetSegmentCenterAngle =
            resultIndexOnWheel * segmentAngle + segmentAngle / 2;
          const finalTargetAngle = targetSegmentCenterAngle + randomOffset;

          currentRouletteResultNumber = resultNumber;
          currentRouletteFinalTargetAngle = finalTargetAngle;

          const targetViewAngle = (270 - finalTargetAngle + 360) % 360;
          let rotationNeeded = targetViewAngle - currentAngle;
          if (rotationNeeded < 0) rotationNeeded += 360;
          const fullRotations = 360 * (Math.floor(Math.random() * 4) + 5);
          const rotationAmount = fullRotations + rotationNeeded;
          rotationDegree += rotationAmount;
          rouletteWheel.style.transform = `rotate(${rotationDegree}deg)`;

          startRouletteAudio(segmentAngle);

          startButton.textContent = "スキップ";
          startButton.disabled = false;

          rouletteSpinTimeoutId = setTimeout(() => {
            playSound(sounds.rouletteResult);
            showResultPopup(resultNumber);
            addToHistory(resultNumber);
            setControlsDisabled(false);
            startButton.textContent = "スタート！";
            rouletteSpinTimeoutId = null;
          }, 5100);
        };

        const startCardMode = (numbers) => {
          availableCards = [...numbers];
          cardGrid.innerHTML = "";
          cardMessage.textContent = "好きなカードを1枚選んでください";
          for (let i = availableCards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableCards[i], availableCards[j]] = [
              availableCards[j],
              availableCards[i],
            ];
          }
          availableCards.forEach((num) => {
            const card = document.createElement("div");
            card.className = "card";
            card.dataset.number = num;
            card.innerHTML = `<div class="card-inner"><div class="card-front"></div><div class="card-back">${num}</div></div>`;
            card.addEventListener("click", handleCardClick, { once: true });
            cardGrid.appendChild(card);
          });
          cardGameActive = true;
          setControlsDisabled(true);
          startButton.disabled = false;
        };

        const handleCardClick = (e) => {
          const clickedCard = e.currentTarget;
          const resultNumber = parseInt(clickedCard.dataset.number);
          playSound(sounds.cardFlip);
          clickedCard.classList.add("flipped");
          const resultValue = isNaN(resultNumber)
            ? clickedCard.dataset.number
            : resultNumber;
          addToHistory(resultValue);
          const idx = availableCards.indexOf(resultValue);
          if (idx !== -1) availableCards.splice(idx, 1);
          if (availableCards.length === 0) {
            cardMessage.textContent = "すべてのカードを引きました！";
            cardGameActive = false;
            setControlsDisabled(false);
          }
        };

        // --- リセットボタン処理 ---
        resetButton.addEventListener("click", () => {
          drawnNumbers = [];
          historyList.innerHTML = "";
          setControlsDisabled(false);
          cardGameActive = false;
          resultDisplay.textContent = "?";
          resultDisplay.classList.remove("zoom");
          rouletteWheel.style.transition = "none";
          rotationDegree = 0;
          rouletteWheel.style.transform = `rotate(${rotationDegree}deg)`;
          rouletteWheel.innerHTML = "";
          rouletteWheel.style.background = "none";
          setTimeout(() => {
            rouletteWheel.style.transition =
              "transform 5s cubic-bezier(0.1, 0.8, 0.2, 1)";
          }, 50);
          cardGrid.innerHTML = "";
          cardMessage.textContent = "スタートボタンを押してカードを準備";
          availableCards = [];
          startButton.textContent =
            currentMode === "card" ? "カードを準備" : "スタート！";

          if (currentMode === "card") {
            const availableNumbers = getAvailableNumbers();
            if (availableNumbers && availableNumbers.length > 0) {
              startCardMode(availableNumbers);
            } else {
              cardMessage.textContent = "すべての数字を引き終えました！";
              setControlsDisabled(false);
            }
          }

          if (rouletteSpinTimeoutId) {
            clearTimeout(rouletteSpinTimeoutId);
            rouletteSpinTimeoutId = null;
          }

          stopRouletteAudio();
        });

        // タイマーモードのロジック
        const updateTimerDisplay = () => {
          const minutes = Math.floor(timerModeTimeLeft / 60);
          const seconds = timerModeTimeLeft % 60;
          timerDisplayMode.textContent = `${String(minutes).padStart(
            2,
            "0"
          )}:${String(seconds).padStart(2, "0")}`;
        };

        const startTimerMode = () => {
          if (timerModeIsRunning) return;
          if (timerModeTimeLeft <= 0) {
            timerModeTimeLeft =
              parseInt(timerMinutesInput.value || "0") * 60 +
              parseInt(timerSecondsInput.value || "0");
            if (timerModeTimeLeft <= 0) return;
          }
          timerModeIsRunning = true;
          timerStartBtn.textContent = "再開";
          timerPauseBtn.disabled = false;
          timerResetBtn.disabled = false;
          timerMinutesInput.disabled = true;
          timerSecondsInput.disabled = true;

          timerModeInterval = setInterval(() => {
            if (timerModeTimeLeft <= 0) {
              clearInterval(timerModeInterval);
              timerModeIsRunning = false;
              timerStartBtn.textContent = "スタート";
              timerPauseBtn.disabled = true;
              alert("時間になりました！");
            } else {
              timerModeTimeLeft--;
              updateTimerDisplay();
            }
          }, 1000);
        };

        const pauseTimerMode = () => {
          clearInterval(timerModeInterval);
          timerModeIsRunning = false;
          timerStartBtn.textContent = "再開";
        };

        const resetTimerMode = () => {
          clearInterval(timerModeInterval);
          timerModeIsRunning = false;
          timerModeTimeLeft =
            parseInt(timerMinutesInput.value || "0") * 60 +
            parseInt(timerSecondsInput.value || "0");
          updateTimerDisplay();
          timerStartBtn.textContent = "スタート";
          timerPauseBtn.disabled = true;
          timerResetBtn.disabled = true;
          timerMinutesInput.disabled = false;
          timerSecondsInput.disabled = false;
        };

        const updateTimerFromInput = () => {
          if (!timerModeIsRunning) {
            timerModeTimeLeft =
              parseInt(timerMinutesInput.value || "0") * 60 +
              parseInt(timerSecondsInput.value || "0");
            updateTimerDisplay();
          }
        };
        timerMinutesInput.addEventListener("input", updateTimerFromInput);
        timerSecondsInput.addEventListener("input", updateTimerFromInput);
        timerStartBtn.addEventListener("click", startTimerMode);
        timerPauseBtn.addEventListener("click", pauseTimerMode);
        timerResetBtn.addEventListener("click", resetTimerMode);

        updateTimerFromInput();
      });

      let lastTouchEnd = 0;
      document.addEventListener(
        "touchend",
        function (event) {
          const now = new Date().getTime();
          if (now - lastTouchEnd <= 300) {
            event.preventDefault();
          }
          lastTouchEnd = now;
        },
        false
      );
    </script>
  </body>
</html>