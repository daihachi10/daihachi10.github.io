<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ルーレット | daihachi</title>
    <style>
      :root {
        --logo-color: #1db31d;
        --color-primary: #1a73e8;
        --color-primary-dark: #0f3d7a;
        --color-primary-light: #e8f0fe;
        --color-primary-disabled: #a0c3f0;
        --color-accent: #e94560;
        --color-text-primary: #333;
        --color-text-secondary: #5f6368;
        --color-white: #ffffff;
        --color-bg: #f0f2f5;
        --color-bg-alt: #f8f9fa;
        --color-bg-secondary: #e0e0e0;
        --color-bg-secondary-hover: #c7c7c7;
        --color-bg-focus: #dbe4f0;
        --color-border: #ddd;
        --color-border-light: #e0e2e5;
        --color-card: #4a90e2;
        --color-card-back: #f7f7f7;
        --color-neutral-dark: #34495e;
        --shadow-color-light: rgba(0, 0, 0, 0.1);
        --shadow-color-medium: rgba(0, 0, 0, 0.15);
        --overlay-bg: rgba(0, 0, 0, 0.6);
        --roulette-number-bg: rgba(255, 255, 255, 0.8);
        --radius: 50px;

        /* Drag & Drop specific colors */
        --drag-dest-highlight: #cce5ff;
        --drag-line-color: #1a73e8;
      }

      /* 基本スタイル */
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        background-color: var(--color-bg);
        color: var(--color-text-primary);
        display: flex;
        justify-content: center;
        align-items: center; /* 垂直方向も中央揃えに */
        min-height: 100vh;
        margin: 0;
        padding: 20px;
        box-sizing: border-box;
        transition: background-color 0.5s ease;
      }

      .hidden-force {
        display: none !important;
      }

      .home {
        font-family: "Caveat", cursive;
        text-decoration: none;
        font-size: 20px;
        width: 25px;
        height: 25px;
        position: absolute;
        bottom: 20px;
        right: 70px;
        color: var(--color-primary);
      }

      /* フォーカスモード時の背景 */
      body.focus-mode-on {
        background-color: var(--color-bg-focus);
      }

      .container {
        background-color: var(--color-white);
        padding: 30px 40px;
        border-radius: 16px;
        box-shadow: 0 8px 25px var(--shadow-color-light);
        text-align: center;
        width: 100%;
        max-width: 450px;
        position: relative;
        transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* フォーカスモード時のコンテナスタイル */
      .focus-mode-on .container {
        max-width: 80vw;
        height: 80vh;
        box-shadow: 0 15px 40px var(--shadow-color-medium);
      }

      /* 右上のボタングループ */
      .top-right-buttons {
        position: absolute;
        top: 15px;
        right: 15px;
        display: flex;
        gap: 10px;
        z-index: 20;
        align-items: center;
      }

      .profile-name-display {
        font-size: 0.9rem;
        color: var(--color-text-secondary);
        margin-right: 10px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100px;
        transition: opacity 0.3s ease;
      }

      .focus-mode-on .profile-name-display {
        opacity: 0;
        pointer-events: none;
      }

      /* フォーカス切り替えボタン */
      .focus-toggle-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: var(--color-bg);
        border: 1px solid var(--color-border-light);
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0;
        transition: all 0.3s ease;
      }
      .focus-toggle-btn:hover {
        background-color: var(--color-primary-light);
        border-color: var(--color-primary-disabled);
      }
      .focus-toggle-btn svg {
        width: 20px;
        height: 20px;
        color: var(--color-text-secondary);
      }
      .focus-mode-off .icon-shrink,
      .focus-mode-on .icon-expand {
        display: none;
      }

      h1.main-title {
        color: var(--color-primary);
        margin-bottom: 20px;
      }

      /* 非表示になるコントロールパネルの共通スタイル */
      .control-panel {
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .focus-mode-on .control-panel {
        opacity: 0;
        transform: translateY(-15px);
        height: 0;
        overflow: hidden;
        margin-top: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
      }
      .focus-mode-on h1.main-title {
        opacity: 0;
        height: 0;
        overflow: hidden;
        margin-bottom: 0;
      }

      /* ゲームエリア */
      .game-area {
        min-height: 280px;
        position: relative;
        margin-bottom: 20px;
        transition: min-height 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .focus-mode-on .game-area {
        min-height: 450px;
        margin-top: 40px;
      }

      .focus-mode-on #result-display {
        transform: scale(1.2);
      }

      /* ルーレットモード */
      .roulette-container {
        transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .roulette-wheel {
        transition: transform 5s cubic-bezier(0.1, 0.8, 0.2, 1);
      }
      .focus-mode-on .roulette-container {
        transform: scale(1.4);
      }

      /* カード選択モード */
      .focus-mode-on .card-grid {
        gap: 15px;
      }
      .focus-mode-on .card {
        height: 100px;
      }

      /* 履歴エリア */
      .history-area {
        margin-top: 20px;
      }

      /* モード選択 */
      .mode-selector {
        position: relative;
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
        border: 1px solid var(--color-border);
        border-radius: var(--radius);
        overflow: hidden;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      .mode-highlight {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        background-color: var(--color-primary-light);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 0;
      }
      .mode-btn {
        position: relative;
        z-index: 1;
        flex: 1;
        padding: 10px;
        border: none;
        background-color: transparent;
        cursor: pointer;
        font-size: 0.9rem;
        color: var(--color-text-secondary);
        transition: color 0.3s;
      }
      .mode-btn.active {
        font-weight: bold;
      }

      /* 設定・オプション */
      .settings,
      .options {
        margin-bottom: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
      }
      input[type="number"] {
        width: 60px;
        padding: 8px;
        border: 1px solid var(--color-border);
        border-radius: var(--radius);
        text-align: center;
        font-size: 1rem;
      }
      input[type="checkbox"] {
        transform: scale(1.2);
        margin-right: 5px;
      }

      /* ボタン */
      .buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-bottom: 25px;
      }
      button {
        padding: 20px 35px;
        font-size: 1.1rem;
        font-weight: bold;
        border: none;
        border-radius: var(--radius);
        cursor: pointer;
        transition: background-color 0.3s, transform 0.1s;
      }
      #start-button {
        background-color: var(--color-primary);
        color: var(--color-white);
      }
      #start-button:hover {
        background-color: var(--color-primary-dark);
      }
      #start-button:disabled {
        background-color: var(--color-primary-disabled);
        cursor: not-allowed;
      }
      #reset-button {
        background-color: var(--color-bg-secondary);
        color: var(--color-text-primary);
      }
      #reset-button:hover {
        background-color: var(--color-bg-secondary-hover);
      }
      button:active {
        transform: scale(0.9);
      }

      .mode-content {
        position: absolute;
        width: 100%;
        top: 0;
        left: 0;
        opacity: 0;
        transform: translateX(15px);
        pointer-events: none;
        transition: opacity 0.4s ease, transform 0.4s ease;
      }
      .mode-content.active {
        opacity: 1;
        transform: translateX(0);
        pointer-events: auto;
      }

      /* シンプルモード */
      #simple-mode-area {
        padding: 20px;
        border-radius: 10px;
        box-sizing: border-box;
      }
      #simple-mode-area p {
        margin: 0 0 10px 0;
        font-size: 1rem;
        color: var(--color-text-secondary);
      }
      .result-box {
        font-size: 5rem;
        font-weight: bold;
        color: var(--color-primary);
        min-height: 80px;
        line-height: 80px;
      }
      .zoom {
        animation: result-reveal-animation 0.8s
          cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      }

      @keyframes result-reveal-animation {
        0% {
          transform: translateY(20px) scale(0.8);
          opacity: 0;
        }
        50% {
          transform: translateY(-10px) scale(1.1);
          opacity: 1;
        }
        100% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
      }

      /* ルーレットモード */
      .roulette-container {
        position: relative;
        width: 280px;
        height: 280px;
        margin: 0 auto;
      }

      .focus-mode-on .roulette-container {
        width: 400px;
        height: 400px;
      }

      .roulette-pointer {
        position: absolute;
        top: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 15px solid transparent;
        border-right: 15px solid transparent;
        border-top: 30px solid var(--color-accent);
        z-index: 10;
      }
      .roulette-wheel {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 5px solid var(--color-neutral-dark);
        position: relative;
        transition: transform 5s cubic-bezier(0.1, 0.8, 0.2, 1);
        overflow: hidden;
      }
      .roulette-wheel .number {
        position: absolute;
        top: 50%;
        left: 50%;
        transform-origin: center left;
        width: 100px;
        height: 1px;
        display: flex;
        justify-content: flex-end;
        align-items: center;
      }
      .roulette-wheel .number span {
        display: block;
        transform: rotate(90deg);
        font-weight: bold;
        font-size: 1rem;
        color: var(--color-text-primary);
        padding: 3px 8px;
        background-color: var(--roulette-number-bg);
        border-radius: 5px;
        transition: opacity 0.3s ease;
      }

      .roulette-wheel .number.drawn span {
        opacity: 0.2;
      }

      .focus-mode-on .roulette-wheel .number {
        width: 185px;
      }

      .focus-mode-on .roulette-wheel .number span {
        background-color: transparent;
        color: var(--color-white);
        /* font-size: 1.1rem; ← JSで上書きされるためコメントアウト的扱いになります */
        text-shadow: 0 0 4px rgba(0, 0, 0, 0.6);
      }

      /* カード選択モード */
      #card-message {
        margin-top: 10px;
        color: var(--color-text-secondary);
        min-height: 24px;
      }
      .card-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
        gap: 10px;
        padding: 10px;
        max-height: 240px;
        overflow-y: auto;
      }
      .card {
        height: 60px;
        background-color: var(--color-card);
        border-radius: 8px;
        cursor: pointer;
        perspective: 1000px;
      }
      .card.flipped {
        pointer-events: none;
      }
      .card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        text-align: center;
        transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        transform-style: preserve-3d;
      }

      .card.flipped .card-inner {
        transform: rotateY(180deg);
      }
      .card-front,
      .card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 6px;
      }
      .card-front {
        background-color: var(--color-card);
        color: var(--color-white);
        font-size: 2rem;
        font-weight: bold;
      }
      .card-front::before {
        content: "?";
      }
      .card-back {
        background-color: var(--color-card-back);
        color: var(--color-text-primary);
        transform: rotateY(180deg);
        font-size: 1.8rem;
        font-weight: bold;
      }

      /* 履歴エリア */
      #history-list {
        list-style: none;
        padding: 0;
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
        max-height: 120px;
        overflow-y: auto;
        background-color: var(--color-bg-alt);
        border: 1px solid var(--color-border);
        border-radius: 20px;
        padding: 30px;
      }
      #history-list li {
        background-color: var(--color-white);
        color: var(--color-text-secondary);
        padding: 5px 12px;
        border-radius: 15px;
        border: 1px solid var(--color-border-light);
        font-size: 0.9rem;
      }

      /* 結果表示オーバーレイ */
      #result-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--overlay-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.4s ease-in-out;
        pointer-events: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      #result-overlay:not(.hidden) {
        opacity: 1;
        pointer-events: auto;
      }
      #result-popup {
        font-size: 10rem;
        font-weight: bold;
        color: var(--color-white);
        padding: 40px 60px;
        background-color: var(--color-primary);
        border-radius: 20px;
        transform: scale(0.7) translateY(20px);
        opacity: 0;
        transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1),
          opacity 0.3s ease;
      }
      #result-overlay:not(.hidden) #result-popup {
        transform: scale(1) translateY(0);
        opacity: 1;
      }

      /* レスポンシブ対応 */
      @media (max-width: 480px) {
        .container {
          padding: 20px;
        }
        h1 {
          font-size: 1.8rem;
        }
        .buttons {
          flex-direction: column;
        }
        #result-popup {
          font-size: 6rem;
        }
      }

      /* 設定モーダル */
      #settings-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--overlay-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1100;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
        pointer-events: none;
      }
      #settings-modal:not(.hidden) {
        opacity: 1;
        pointer-events: auto;
      }
      .modal-content {
        background-color: var(--color-white);
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 8px 25px var(--shadow-color-medium);
        width: 90%;
        max-width: 728px;
        position: relative;
        transform: scale(0.9);
        transition: transform 0.3s ease;
        max-height: 95vh; /* 画面が小さいときにはみ出さないように */
        overflow-y: auto; /* スクロール可能に */
      }
      .adbox {
        text-align: center;
        padding-bottom: 20px;
      }

      .ad-text {
        font-size: 0.8rem;
        color: var(--color-text-secondary);
      }
      #close-ad-btn {
        margin-bottom: 10px;
        padding: 8px 16px;
        font-size: 0.9rem;
        background-color: var(--color-bg-secondary);
        border: none;
        border-radius: var(--radius);
        cursor: pointer;
        transition: background-color 0.3s, transform 0.1s;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-left: auto;
        margin-right: 0;
      }

      .hidden.adbox {
        display: none !important;
      }
      #settings-modal:not(.hidden) .modal-content {
        transform: scale(1);
      }
      .close-btn {
        position: absolute;
        top: 10px;
        right: 15px;
        color: var(--color-text-secondary);
        background: none;
        border: none;
        cursor: pointer;
        padding: 0;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .setting-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 20px;
      }
      .setting-item label {
        font-size: 1rem;
      }
      #volume-slider {
        width: 60%;
      }

      /* =========================================
         プロファイル・フォルダ管理セクション (NEW)
         ========================================= */
      .profiles-section {
        margin-top: 20px;
        text-align: left;
      }
      .profiles-section h3 {
        margin-bottom: 10px;
        color: var(--color-text-primary);
      }

      /* ツリー表示用コンテナ */
      #profiles-container {
        display: flex;
        flex-direction: column;
        gap: 5px;
        min-height: 50px;
        padding-bottom: 20px;
      }

      /* アイテム（プロファイル・フォルダ共通） */
      .tree-item {
        position: relative;
        user-select: none;
      }

      /* プロファイルアイテム */
      .profile-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
        background-color: var(--color-bg-alt);
        border: 1px solid var(--color-border);
        border-radius: var(--radius);
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .profile-item.active {
        background-color: var(--color-primary-light);
        border-color: var(--color-primary);
        font-weight: bold;
      }
      .profile-item:hover:not(.active) {
        background-color: var(--color-bg-secondary);
      }
      .profile-item .profile-name {
        flex-grow: 1;
      }

      /* フォルダアイテム */
      .folder-item {
        border: 1px solid var(--color-border);
        border-radius: 12px;
        background-color: #fcfcfc;
        margin-bottom: 5px;
        overflow: hidden;
      }
      .folder-header {
        display: flex;
        align-items: center;
        padding: 10px 12px;
        background-color: #eaeaea;
        cursor: pointer;
        font-weight: bold;
        color: var(--color-neutral-dark);
        gap: 8px;
      }
      .folder-header:hover {
        background-color: #dcdcdc;
      }
      .folder-content {
        padding: 5px 5px 5px 20px; /* 左側にインデント */
        display: flex;
        flex-direction: column;
        gap: 5px;
        min-height: 10px; /* ドロップ領域確保 */
        background-color: #f9f9f9;
      }
      .folder-content.collapsed {
        display: none;
      }
      .folder-arrow {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        color: var(--color-text-secondary);
        margin-right: 2px;
      }
      .folder-arrow svg {
        width: 24px;
        height: 24px;
        fill: currentColor;
      }

      /* アイコン */
      .icon-folder,
      .icon-profile {
        width: 20px;
        height: 20px;
        fill: currentColor;
        color: var(--color-text-secondary);
      }
      .folder-header .icon-folder {
        color: #ffca28; /* Folder Color */
      }

      /* DnD Visual Feedback */
      .drag-over-folder {
        background-color: var(--drag-dest-highlight) !important;
        border: 2px dashed var(--color-primary) !important;
      }
      .drag-over-top {
        border-top: 3px solid var(--drag-line-color) !important;
      }
      .drag-over-bottom {
        border-bottom: 3px solid var(--drag-line-color) !important;
      }
      .tree-item.dragging {
        opacity: 0.5;
      }

      /* アクションボタン（ツリー内の3点リーダー） */
      .item-actions {
        margin-left: auto;
        display: flex;
        gap: 5px;
      }
      .action-btn {
        background: none;
        border: none;
        color: var(--color-text-secondary);
        cursor: pointer;
        padding: 4px;
        border-radius: 20px;
        opacity: 0.6;
        transition: opacity 0.2s, background-color 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .tree-item:hover .action-btn,
      .folder-header:hover .action-btn {
        opacity: 1;
      }
      .action-btn:hover {
        background-color: rgba(0, 0, 0, 0.1);
      }

      /* 新規追加ボタン（ドロップダウン） */
      .add-menu-wrapper {
        position: relative;
        display: inline-block;
        margin-top: 10px;
      }
      #add-btn-trigger {
        padding: 8px 16px;
        font-size: 0.9rem;
        background-color: var(--color-bg-secondary);
        border: 1px dashed var(--color-border);
        color: var(--color-text-secondary);
        border-radius: var(--radius);
        cursor: pointer;
      }
      #add-btn-trigger:hover {
        background-color: var(--color-bg-secondary-hover);
      }
      .add-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        background-color: white;
        border: 1px solid var(--color-border);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: none;
        z-index: 100;
        min-width: 220px;
        overflow: hidden;
      }
      .add-dropdown.visible {
        display: block;
      }
      .add-option {
        padding: 10px 15px;
        cursor: pointer;
        transition: background-color 0.2s;
        text-align: left;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .add-option:hover {
        background-color: var(--color-primary-light);
        color: var(--color-primary);
      }

      /* プロファイル用カスタムコンテキストメニュー */
      #profile-context-menu {
        position: fixed;
        z-index: 1200;
        background-color: var(--color-white);
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        padding: 8px 0;
        min-width: 150px;
        opacity: 0;
        transform: scale(0.95);
        transform-origin: top left;
        transition: opacity 0.15s ease, transform 0.15s ease;
        pointer-events: none;
      }

      #profile-context-menu.visible {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
      }

      .context-menu-item {
        padding: 10px 20px;
        cursor: pointer;
        font-size: 0.9rem;
        color: var(--color-text-primary);
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .context-menu-item:hover {
        background-color: var(--color-primary-light);
        color: var(--color-primary);
      }

      .context-menu-separator {
        height: 1px;
        background-color: var(--color-border);
        margin: 5px 0;
      }

      .focus-mode-on #roulette-mode-area {
        margin-top: 120px;
      }

      .focus-mode-on #result-display {
        padding-top: 200px;
        font-size: 20rem;
      }

      body {
        overflow: hidden;
      }

      #names-list,
      #exclude-numbers,
      #history-list {
        border-radius: 20px !important;
      }
      #reset-local-storage-btn {
        background-color: var(--color-bg-secondary);
        color: var(--color-text-primary);
        padding: 10px 20px;
        border: none;
        border-radius: var(--radius);
        cursor: pointer;
        font-size: 1rem;
        transition: background-color 0.3s, transform 0.1s;
      }

      /* インポートボタン用スタイル */
      #import-profile-btn {
        background-color: #fff;
        color: var(--color-primary);
        padding: 10px 0px;
        border: none;
        border-radius: var(--radius);
        cursor: pointer;
        font-size: 1rem;
        margin-left: 10px;
        transition: background-color 0.3s, transform 0.1s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .github-open-button {
        padding-left: 15px;
        color: var(--color-primary);
        text-decoration: none;
      }

      #open-in-new-tab-icon {
        color: var(--color-primary);
        fill: var(--color-primary);
      }

      /* ★★★ 新着情報セクションのスタイル ★★★ */
      .news-section {
        margin-top: 25px;
        text-align: left;
      }

      .news-box {
        height: 140px;
        overflow-y: scroll;
      }

      .news-section h3 {
        margin-bottom: 10px;
        font-size: 1.1rem;
        color: var(--color-text-primary);
      }
      .news-item {
        border: 1px solid var(--color-border);
        border-radius: 12px;
        padding: 15px;
        background-color: var(--color-bg-alt);
        margin-bottom: 10px;
      }
      .news-header {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        flex-wrap: wrap;
        gap: 10px;
      }
      .news-version {
        font-weight: bold;
        color: var(--color-white);
        background-color: var(--color-primary);
        padding: 3px 8px;
        border-radius: 6px;
        font-size: 0.8rem;
      }
      .news-title {
        font-weight: bold;
        font-size: 1rem;
        color: var(--color-text-primary);
      }
      .news-detail {
        font-size: 0.9rem;
        color: var(--color-text-secondary);
        line-height: 1.5;
        margin-left: 2px;
      }

      /* Timer Display Styles */
      .timer-display {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 10em;
        font-weight: bold;
        color: var(--color-primary);
        z-index: 1000;
        text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.3);
      }

      .result-timer-display {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 2em;
        font-weight: bold;
        color: white;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        z-index: 1001;
      }

      /* Timer Mode Specific Styles */
      #timer-mode-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }

      .timer-input-group {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .timer-input-group input[type="number"] {
        width: 80px;
        padding: 10px;
        font-size: 1.5em;
        text-align: center;
        border: 2px solid var(--color-primary);
        border-radius: 5px;
      }

      .timer-input-group span {
        font-size: 1.5em;
        font-weight: bold;
      }

      .timer-display-mode {
        font-size: 5em;
        font-weight: bold;
        color: var(--color-primary);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }

      .timer-controls {
        display: flex;
        gap: 10px;
      }
    </style>
    <link rel="icon" href="https://daihachi10.github.io/assets/favicon.ico" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Caveat:wght@400..700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body class="focus-mode-off">
    <!-- <a href="https://daihachi10.github.io" class="home"
      ><span id="copy">&copy;</span>Daihachi</a
    > -->
    <div class="container">
      <div class="top-right-buttons">
        <span id="profile-name-display" class="profile-name-display"></span>
        <button
          id="theme-toggle-btn"
          class="focus-toggle-btn"
          title="テーマカラー切り替え"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 -960 960 960"
            fill="currentColor"
          >
            <path
              d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"
            />
          </svg>
        </button>
        <button id="settings-btn" class="focus-toggle-btn" title="設定">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 -960 960 960"
            fill="currentColor"
          >
            <path
              d="M200-160v-280h-80v-80h240v80h-80v280h-80Zm0-440v-200h80v200h-80Zm160 0v-80h80v-120h80v120h80v80H360Zm80 440v-360h80v360h-80Zm240 0v-120h-80v-80h240v80h-80v120h-80Zm0-280v-360h80v360h-80Z"
            />
          </svg>
        </button>
        <button
          id="focus-toggle-btn"
          class="focus-toggle-btn"
          title="フォーカスモード切り替え"
        >
          <svg
            class="icon-expand"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 -960 960 960"
            fill="currentColor"
          >
            <path
              d="M120-120v-200h80v120h120v80H120Zm520 0v-80h120v-120h80v200H640ZM120-640v-200h200v80H200v120h-80Zm640 0v-120H640v-80h200v200h-80Z"
            />
          </svg>
          <svg
            class="icon-shrink"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 -960 960 960"
          >
            <path
              d="M120-120v-200h80v120h120v80H120Zm520 0v-80h120v-120h80v200H640ZM120-640v-200h200v80H200v120h-80Zm640 0v-120H640v-80h200v200h-80Z"
            />
          </svg>
        </button>
      </div>

      <h1 class="main-title">ルーレット</h1>

      <!-- モード選択タブ -->
      <div class="mode-selector control-panel">
        <div class="mode-highlight"></div>
        <button class="mode-btn active" data-mode="simple">シンプル</button>
        <button class="mode-btn" data-mode="roulette">ルーレット</button>
        <button class="mode-btn" data-mode="card">カード選択</button>
      </div>

      <!-- 設定エリア -->
      <div class="settings control-panel"></div>
      <div class="buttons">
        <button id="start-button">スタート！</button>
        <button id="reset-button">リセット</button>
      </div>

      <!-- 各モードの表示エリア -->
      <div class="game-area">
        <!-- シンプルモード -->
        <div id="simple-mode-area" class="mode-content active">
          <p>結果は...</p>
          <div id="result-display" class="result-box">?</div>
        </div>

        <!-- ルーレットモード -->
        <div id="roulette-mode-area" class="mode-content">
          <div class="roulette-container">
            <div class="roulette-pointer"></div>
            <div class="roulette-wheel">
              <!-- JSで数字がここに生成されます -->
            </div>
          </div>
        </div>

        <!-- カード選択モード -->
        <div id="card-mode-area" class="mode-content">
          <p id="card-message">スタートボタンを押してカードを準備</p>
          <div class="card-grid">
            <!-- JSでカードがここに生成されます -->
          </div>
        </div>

        <!-- タイマーモード -->
        <div id="timer-mode-area" class="mode-content">
          <div class="timer-input-group">
            <input
              type="number"
              id="timer-minutes"
              value="0"
              min="0"
              max="59"
            />
            <span>:</span>
            <input
              type="number"
              id="timer-seconds"
              value="0"
              min="0"
              max="59"
            />
          </div>
          <div id="timer-display-mode" class="timer-display-mode">00:00</div>
          <div class="timer-controls">
            <button id="timer-start-btn">スタート</button>
            <button id="timer-pause-btn">一時停止</button>
            <button id="timer-reset-btn">リセット</button>
          </div>
        </div>
      </div>

      <div class="history-area control-panel">
        <ul id="history-list">
          <!-- ここに引いた数字の履歴が追加されます -->
        </ul>
      </div>
    </div>

    <!-- 結果表示用オーバーレイ -->
    <div id="result-overlay" class="hidden">
      <div id="result-popup"></div>
      <div id="result-timer-display" class="result-timer-display"></div>
    </div>

    <!-- 設定モーダル -->
    <div id="settings-modal" class="hidden">
      <div class="modal-content">
        <button id="close-modal-btn" class="close-btn"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button>
        <h2>設定</h2>
        <div class="setting-item">
          <label for="volume-slider">効果音の音量</label>
          <input
            type="range"
            id="volume-slider"
            min="0"
            max="1"
            step="0.0001"
            value="0.05"
          />
        </div>

        <hr />

        <!-- モード切り替えスイッチ -->
        <div style="margin-bottom: 15px">
          <label style="cursor: pointer; font-weight: bold; font-size: 1.1rem">
            <input type="checkbox" id="use-names-checkbox" />
            名前でルーレットする
          </label>
        </div>

        <!-- 数値モード用設定エリア (IDを追加してグループ化) -->
        <div id="number-settings-container">
          <div style="margin-bottom: 15px">
            <label for="min-number">範囲:</label>
            <input type="number" id="min-number" value="1" />
            <span>～</span>
            <input type="number" id="max-number" value="35" />
          </div>

          <div>
            <label
              for="exclude-numbers"
              style="display: block; margin-bottom: 5px"
              >除外する番号 (カンマ区切り):</label
            >
            <input
              type="text"
              id="exclude-numbers"
              placeholder="例: 4, 15, 22"
              style="
                width: 95%;
                padding: 8px;
                border-radius: 5px;
                border: 1px solid var(--color-border);
              "
            />
          </div>
        </div>

        <!-- 名前モード用設定エリア (IDを追加してグループ化) -->
        <div id="name-settings-container" style="display: none">
          <textarea
            id="names-list"
            placeholder="名前を改行区切りで入力してください。"
            style="
              width: 95%;
              height: 120px;
              padding: 8px;
              border-radius: 5px;
              border: 1px solid var(--color-border);
              margin-top: 5px;
            "
          ></textarea>
        </div>

        <div
          class="options control-panel"
          style="margin-top: 20px; display: none"
        >
          <input type="checkbox" id="no-duplicates" checked />
          <label for="no-duplicates">一度引いた数字(または名前)は出ない</label>
        </div>
        <hr />

        <!-- ★★★ プロファイル・フォルダ管理セクション ★★★ -->
        <div class="profiles-section">
          <h3>プロファイルとフォルダ</h3>

          <div id="profiles-container">
            <!-- JSでツリー生成 -->
          </div>

          <div class="add-menu-wrapper">
            <button id="add-btn-trigger">+ 追加</button>
            <div id="add-dropdown" class="add-dropdown">
              <div class="add-option" data-action="add-profile">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  height="24px"
                  viewBox="0 -960 960 960"
                  width="24px"
                  fill="currentColor"
                >
                  <path
                    d="M234-276q51-39 114-61.5T480-360q69 0 132 22.5T726-276q35-41 54.5-93T800-480q0-133-93.5-226.5T480-800q-133 0-226.5 93.5T160-480q0 59 19.5 111t54.5 93Zm246-164q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0 360q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q53 0 100-15.5t86-44.5q-39-29-86-44.5T480-280q-53 0-100 15.5T294-220q39 29 86 44.5T480-160Zm0-360q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0-60Zm0 360Z"
                  />
                </svg>
                プロファイルを追加
              </div>
              <div class="add-option" data-action="add-folder">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  height="24px"
                  viewBox="0 -960 960 960"
                  width="24px"
                  fill="currentColor"
                >
                  <path
                    d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h240l80 80h320q33 0 56.5 23.5T880-640v400q0 33-23.5 56.5T800-160H160Zm0-80h640v-400H447l-80-80H160v480Zm0 0v-480 480Z"
                  />
                </svg>
                フォルダを追加
              </div>
            </div>
          </div>
        </div>

        <div>
          <!-- インポートボタンと隠しファイル入力 -->
          <button id="import-profile-btn"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M480-80 200-360l56-57 184 184v-287h80v287l184-183 56 56L480-80Zm-40-520v-120h80v120h-80Zm0-200v-80h80v80h-80Z"/></svg>インポート</button>
          <input
            type="file"
            id="import-file-input"
            accept=".json"
            style="display: none"
          />
        </div>
        <hr />

        <!-- ★★★ 新着情報セクション ★★★ -->
        <div class="news-section">
          <h3>新着情報</h3>
          <div class="news-box">

            <div class="news-item">
              <div class="news-header">
                <span class="news-version">V0.3</span>
                <span class="news-title">フォルダ機能とドラッグ＆ドロップ</span>
              </div>
              <div class="news-detail">
                プロファイルをフォルダで整理できるようになりました。ドラッグ＆ドロップで並べ替えやフォルダへの移動が可能です。
              </div>
            </div>
            <div class="news-item">
              <div class="news-header">
                <span class="news-version">V0.2</span>
                <span class="news-title">プロファイルの保存機能強化</span>
              </div>
              <div class="news-detail">
                名前リストがPCに自動保存されるようになり、プロファイルのインポート・エクスポート機能を追加しました。
              </div>
            </div>

          </div>
        </div>

        <div class="adbox" id="adbox">
          <hr />
          <span class="ad-text">広告</span>
          <button id="close-ad-btn"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button>
          <!-- admax -->
          <div
            class="admax-ads"
            data-admax-id="cfc35a98056c136d0b6a6ea4ced854dc"
            style="display: inline-block; width: 728px; height: 90px"
          ></div>
          <script type="text/javascript">
            (admaxads = window.admaxads || []).push({
              admax_id: "cfc35a98056c136d0b6a6ea4ced854dc",
              type: "banner",
            });
          </script>
          <script
            type="text/javascript"
            charset="utf-8"
            src="https://adm.shinobi.jp/st/t.js"
            async
          ></script>
          <!-- admax -->
        </div>
      </div>
    </div>

    <!-- プロファイル用カスタムコンテキストメニュー -->
    <div id="profile-context-menu">
      <div class="context-menu-item hidden-force" data-action="load">読み込み</div>
      <div class="context-menu-item hidden-force" data-action="save">現在の設定を保存</div>
      <!-- エクスポートメニューを追加 -->
      <div class="context-menu-item" data-action="export">
        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M480-480ZM202-65l-56-57 118-118h-90v-80h226v226h-80v-89L202-65Zm278-15v-80h240v-440H520v-200H240v400h-80v-400q0-33 23.5-56.5T240-880h320l240 240v480q0 33-23.5 56.5T720-80H480Z"/></svg>
        エクスポート
      </div>
      <div class="context-menu-item" data-action="rename">
        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M563-491q73-54 114-118.5T718-738q0-32-10.5-47T679-800q-47 0-83 79.5T560-541q0 14 .5 26.5T563-491ZM120-120v-80h80v80h-80Zm160 0v-80h80v80h-80Zm160 0v-80h80v80h-80Zm160 0v-80h80v80h-80Zm160 0v-80h80v80h-80ZM136-280l-56-56 64-64-64-64 56-56 64 64 64-64 56 56-64 64 64-56 56-64-64-64 64Zm482-40q-30 0-55-11.5T520-369q-25 14-51.5 25T414-322l-28-75q28-10 53.5-21.5T489-443q-5-22-7.5-48t-2.5-56q0-144 57-238.5T679-880q52 0 85 38.5T797-734q0 86-54.5 170T591-413q7 7 14.5 10.5T621-399q26 0 60.5-33t62.5-87l73 34q-7 17-11 41t1 42q10-5 23.5-17t27.5-30l63 49q-26 36-60 58t-63 22q-21 0-37.5-12.5T733-371q-28 25-57 38t-58 13Z"/></svg>
        名前の変更
      </div>
      <div
        class="context-menu-item"
        data-action="delete"
        style="color: #e94560"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          height="24px"
          viewBox="0 -960 960 960"
          width="24px"
          fill="currentColor"
        >
          <path
            d="m376-300 104-104 104 104 56-56-104-104 104-104-56-56-104 104-104-104-56 56 104 104-104 104 56 56Zm-96 180q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520Zm-400 0v520-520Z"
          />
        </svg>
        削除
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // HTML要素の取得
        const body = document.body;
        const themeToggleButton = document.getElementById("theme-toggle-btn");
        const focusToggleButton = document.getElementById("focus-toggle-btn");
        const minNumInput = document.getElementById("min-number");
        const maxNumInput = document.getElementById("max-number");
        const excludeNumbersInput = document.getElementById("exclude-numbers");
        const noDuplicatesCheckbox = document.getElementById("no-duplicates");
        const startButton = document.getElementById("start-button");
        const resetButton = document.getElementById("reset-button");
        const historyList = document.getElementById("history-list");
        const profileNameDisplay = document.getElementById(
          "profile-name-display"
        );

        // --- 新しく追加した要素 ---
        const useNamesCheckbox = document.getElementById("use-names-checkbox");
        const namesListInput = document.getElementById("names-list");
        const numberSettingsContainer = document.getElementById(
          "number-settings-container"
        );
        const nameSettingsContainer = document.getElementById(
          "name-settings-container"
        );

        // インポート関連の要素
        const importProfileBtn = document.getElementById("import-profile-btn");
        const importFileInput = document.getElementById("import-file-input");

        // モード関連の要素
        const modeSelector = document.querySelector(".mode-selector");
        const modeHighlight = document.querySelector(".mode-highlight");
        const modeButtons = document.querySelectorAll(".mode-btn");
        const modeContents = document.querySelectorAll(".mode-content");
        const resultDisplay = document.getElementById("result-display");
        const rouletteWheel = document.querySelector(".roulette-wheel");
        const cardGrid = document.querySelector(".card-grid");
        const cardMessage = document.getElementById("card-message");
        const resultOverlay = document.getElementById("result-overlay");
        const resultPopup = document.getElementById("result-popup");
        const resultTimerDisplay = document.getElementById(
          "result-timer-display"
        );

        // タイマーモード関連の要素
        const timerMinutesInput = document.getElementById("timer-minutes");
        const timerSecondsInput = document.getElementById("timer-seconds");
        const timerDisplayMode = document.getElementById("timer-display-mode");
        const timerStartBtn = document.getElementById("timer-start-btn");
        const timerPauseBtn = document.getElementById("timer-pause-btn");
        const timerResetBtn = document.getElementById("timer-reset-btn");

        // 設定モーダル関連の要素
        const settingsBtn = document.getElementById("settings-btn");
        const settingsModal = document.getElementById("settings-modal");
        const closeModalBtn = document.getElementById("close-modal-btn");
        const volumeSlider = document.getElementById("volume-slider");

        // プロファイル関連の要素 (New)
        const profilesContainer = document.getElementById("profiles-container");
        const contextMenu = document.getElementById("profile-context-menu");
        const addBtnTrigger = document.getElementById("add-btn-trigger");
        const addDropdown = document.getElementById("add-dropdown");

        // ad
        const adCloseBtn = document.getElementById("close-ad-btn");
        const adBanner = document.getElementById("adbox");

        adCloseBtn.addEventListener("click", () => {
          adBanner.classList.add("hidden");
        });

        // --- 設定画面の表示切り替えロジック ---
        const toggleSettingsDisplay = () => {
          if (useNamesCheckbox.checked) {
            // 名前モードON: 数値設定を隠し、名前入力エリアを表示
            numberSettingsContainer.style.display = "none";
            nameSettingsContainer.style.display = "block";
          } else {
            // 名前モードOFF: 数値設定を表示し、名前入力エリアを隠す
            numberSettingsContainer.style.display = "block";
            nameSettingsContainer.style.display = "none";
          }
        };

        // --- 状態管理 ---
        let items = []; // プロファイルとフォルダの統合リスト
        let activeProfileId = null;
        let contextTargetId = null; // コンテキストメニューの対象ID
        let draggingId = null; // DnD中のアイテムID

        // 音声関連のセットアップ
        const sounds = {
          simpleTick: new Audio("./sounds/simple_tick.mp3"),
          simpleResult: new Audio("./sounds/simple_result.mp3"),
          rouletteTick: new Audio("./sounds/roulette_tick.mp3"),
          rouletteResult: new Audio("./sounds/roulette_result.mp3"),
          cardFlip: new Audio("./sounds/card_flip.mp3"),
        };

        Object.values(sounds).forEach((sound) => {
          sound.volume = 0.4;
        });

        // --- 設定モーダルの処理 ---
        settingsBtn.addEventListener("click", () => {
          settingsModal.classList.remove("hidden");
        });

        closeModalBtn.addEventListener("click", () => {
          settingsModal.classList.add("hidden");
        });

        settingsModal.addEventListener("click", (e) => {
          if (e.target === settingsModal) {
            settingsModal.classList.add("hidden");
          }
        });

        volumeSlider.addEventListener("input", (e) => {
          const newVolume = parseFloat(e.target.value);
          Object.values(sounds).forEach((sound) => {
            sound.volume = newVolume;
          });
        });

        // ============================================
        // プロファイル・フォルダ管理ロジック (統合)
        // ============================================

        const saveItems = () => {
          localStorage.setItem("rouletteItems", JSON.stringify(items));
          localStorage.setItem("activeProfileId", activeProfileId);
        };

        const loadItems = () => {
          const savedItems = localStorage.getItem("rouletteItems");
          // 古い形式からの移行用
          const savedOldProfiles = localStorage.getItem("rouletteProfiles");
          const savedActiveId = localStorage.getItem("activeProfileId");

          if (savedItems) {
            try {
              let parsed = JSON.parse(savedItems);
              // データ整合性チェック・補完
              items = parsed.map((item) => {
                if (!item.type) item.type = "profile"; // デフォルト
                if (item.parentId === undefined) item.parentId = null;
                if (item.type === "folder" && item.isCollapsed === undefined)
                  item.isCollapsed = false;
                return item;
              });
            } catch (e) {
              console.error("Data Load Error", e);
              items = [];
            }
          } else if (savedOldProfiles) {
            // 古いデータ形式(単なるプロファイル配列)からの移行
            try {
              const oldProfiles = JSON.parse(savedOldProfiles);
              items = oldProfiles.map((p) => ({
                ...p,
                type: "profile",
                parentId: null,
              }));
              localStorage.removeItem("rouletteProfiles"); // 移行後は削除
            } catch (e) {
              items = [];
            }
          }

          // データが無い場合のデフォルト
          if (items.length === 0) {
            items = [
              {
                id: Date.now(),
                type: "profile",
                name: "デフォルト",
                min: 1,
                max: 35,
                exclude: "",
                useNames: false,
                names: "",
                parentId: null,
              },
            ];
          }

          if (savedActiveId) {
            activeProfileId = parseInt(savedActiveId);
            // 存在確認
            if (
              !items.find(
                (i) => i.id === activeProfileId && i.type === "profile"
              )
            ) {
              const firstProfile = items.find((i) => i.type === "profile");
              activeProfileId = firstProfile ? firstProfile.id : null;
            }
          } else {
            const firstProfile = items.find((i) => i.type === "profile");
            activeProfileId = firstProfile ? firstProfile.id : null;
          }

          applyActiveProfileToInputs();
          renderTree();
        };

        const applyActiveProfileToInputs = () => {
          const profile = items.find((p) => p.id === activeProfileId);
          if (profile) {
            minNumInput.value = profile.min;
            maxNumInput.value = profile.max;
            excludeNumbersInput.value = profile.exclude || "";
            useNamesCheckbox.checked = profile.useNames === true;
            namesListInput.value = profile.names || "";
            profileNameDisplay.textContent = profile.name;
          }
          toggleSettingsDisplay();
        };

        const updateActiveProfileData = () => {
          const profile = items.find((p) => p.id === activeProfileId);
          if (profile) {
            profile.min = parseInt(minNumInput.value);
            profile.max = parseInt(maxNumInput.value);
            profile.exclude = excludeNumbersInput.value;
            profile.useNames = useNamesCheckbox.checked;
            profile.names = namesListInput.value;
            saveItems();
          }
          toggleSettingsDisplay();
        };

        // イベントリスナー (入力変更時即保存)
        minNumInput.addEventListener("change", updateActiveProfileData);
        maxNumInput.addEventListener("change", updateActiveProfileData);
        excludeNumbersInput.addEventListener("change", updateActiveProfileData);
        useNamesCheckbox.addEventListener("change", updateActiveProfileData);
        namesListInput.addEventListener("input", updateActiveProfileData);

        // --- ツリー描画ロジック ---

        // 親IDに基づいてアイテムをフィルタリング
        const getChildren = (parentId) => {
          return items.filter((item) => item.parentId === parentId);
        };

        // アイテム作成（再帰的）
        const createTreeItemElement = (item) => {
          const el = document.createElement("div");
          el.className = "tree-item";
          el.draggable = true;
          el.dataset.id = item.id;
          el.dataset.type = item.type;

          // Drag & Drop Events
          el.addEventListener("dragstart", handleDragStart);
          el.addEventListener("dragover", handleDragOver);
          el.addEventListener("dragleave", handleDragLeave);
          el.addEventListener("drop", handleDrop);
          el.addEventListener("dragend", handleDragEnd);

          if (item.type === "folder") {
            el.classList.add("folder-item");

            const arrowIcon = item.isCollapsed 
              ? `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M400-280v-400l200 200-200 200Z"/></svg>`
              : `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M480-360 280-560h400L480-360Z"/></svg>`;

            // ヘッダー
            const header = document.createElement("div");
            header.className = "folder-header";
            header.innerHTML = `
              <span class="folder-arrow">${arrowIcon}</span>
              <svg class="icon-folder" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h240l80 80h320q33 0 56.5 23.5T880-640v400q0 33-23.5 56.5T800-160H160Zm0-80h640v-400H447l-80-80H160v480Zm0 0v-480 480Z"/></svg>
              <span class="folder-name">${item.name}</span>
            `;

            // アクションボタン
            const actions = document.createElement("div");
            actions.className = "item-actions";
            // MOREアイコン
            actions.innerHTML = `<button class="action-btn menu-btn" title="メニュー"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"/></svg></button>`;
            header.appendChild(actions);

            // コンテキストメニュー用イベント
            header.addEventListener("contextmenu", (e) =>
              showContextMenu(e, item.id)
            );
            actions
              .querySelector(".menu-btn")
              .addEventListener("click", (e) => {
                e.stopPropagation();
                const rect = e.target.getBoundingClientRect();
                showContextMenu(
                  {
                    clientX: rect.left,
                    clientY: rect.bottom,
                    preventDefault: () => {},
                  },
                  item.id
                );
              });

            // フォルダ開閉クリック
            header.addEventListener("click", (e) => {
              if (e.target.closest(".action-btn")) return;
              item.isCollapsed = !item.isCollapsed;
              saveItems();
              renderTree();
            });

            el.appendChild(header);

            // コンテンツエリア（子要素）
            const content = document.createElement("div");
            content.className = `folder-content ${
              item.isCollapsed ? "collapsed" : ""
            }`;
            content.dataset.folderId = item.id; // ドロップ判定用

            const children = getChildren(item.id);
            children.forEach((child) => {
              content.appendChild(createTreeItemElement(child));
            });
            el.appendChild(content);
          } else {
            // プロファイル
            el.classList.add("profile-item");
            if (item.id === activeProfileId) el.classList.add("active");

            el.innerHTML = `
              <svg class="icon-profile" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M234-276q51-39 114-61.5T480-360q69 0 132 22.5T726-276q35-41 54.5-93T800-480q0-133-93.5-226.5T480-800q-133 0-226.5 93.5T160-480q0 59 19.5 111t54.5 93Zm246-164q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0 360q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q53 0 100-15.5t86-44.5q-39-29-86-44.5T480-280q-53 0-100 15.5T294-220q39 29 86 44.5T480-160Zm0-360q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0-60Zm0 360Z"/></svg>
              <span class="profile-name" style="flex-grow:1">${item.name}</span>
              <div class="item-actions">
                <button class="action-btn menu-btn"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"/></svg></button>
              </div>
            `;

            el.addEventListener("click", () => switchProfile(item.id));
            el.addEventListener("contextmenu", (e) =>
              showContextMenu(e, item.id)
            );
            el.querySelector(".menu-btn").addEventListener("click", (e) => {
              e.stopPropagation();
              const rect = e.target.getBoundingClientRect();
              showContextMenu(
                {
                  clientX: rect.left,
                  clientY: rect.bottom,
                  preventDefault: () => {},
                },
                item.id
              );
            });
          }

          return el;
        };

        const renderTree = () => {
          profilesContainer.innerHTML = "";
          // ルート要素（parentId が null）を取得
          const roots = getChildren(null);
          roots.forEach((item) => {
            profilesContainer.appendChild(createTreeItemElement(item));
          });
        };

        // --- Drag & Drop Handlers ---

        function handleDragStart(e) {
          e.stopPropagation(); // 親要素のドラッグ発火を防ぐ
          draggingId = parseInt(this.dataset.id);
          this.classList.add("dragging");
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/plain", draggingId);
        }

        function handleDragOver(e) {
          e.preventDefault(); // ドロップを許可
          e.stopPropagation();
          e.dataTransfer.dropEffect = "move";

          const targetEl = e.currentTarget; // イベントハンドラが設定されている要素（tree-item）
          const targetId = parseInt(targetEl.dataset.id);
          const targetType = targetEl.dataset.type;

          // 自分自身へのドロップは無視
          if (draggingId === targetId) return;

          const rect = targetEl.getBoundingClientRect();
          const relY = e.clientY - rect.top;
          const height = rect.height;

          // 初期化
          targetEl.classList.remove(
            "drag-over-top",
            "drag-over-bottom",
            "drag-over-folder"
          );

          // フォルダへの格納判定 (フォルダの上部・下部以外の中央付近、かつフォルダが開いているかターゲット自体)
          if (targetType === "folder") {
            // フォルダのヘッダー部分に乗っているか、中身か
            if (relY < 10) {
              targetEl.classList.add("drag-over-top"); // 並べ替え（上）
            } else if (
              relY > height - 10 &&
              targetEl.classList.contains("folder-item") &&
              targetEl
                .querySelector(".folder-content")
                .classList.contains("collapsed")
            ) {
              // 折りたたまれているフォルダの下側
              targetEl.classList.add("drag-over-bottom");
            } else {
              // フォルダの中に入れる
              targetEl.classList.add("drag-over-folder");
            }
          } else {
            // プロファイルの場合は上下のみ
            if (relY < height / 2) {
              targetEl.classList.add("drag-over-top");
            } else {
              targetEl.classList.add("drag-over-bottom");
            }
          }
        }

        function handleDragLeave(e) {
          e.currentTarget.classList.remove(
            "drag-over-top",
            "drag-over-bottom",
            "drag-over-folder"
          );
        }

        function handleDrop(e) {
          e.preventDefault();
          e.stopPropagation();
          const targetEl = e.currentTarget;
          targetEl.classList.remove(
            "drag-over-top",
            "drag-over-bottom",
            "drag-over-folder"
          );

          const targetId = parseInt(targetEl.dataset.id);
          if (draggingId === targetId) return;

          const draggingItem = items.find((i) => i.id === draggingId);
          const targetItem = items.find((i) => i.id === targetId);
          if (!draggingItem || !targetItem) return;

          const rect = targetEl.getBoundingClientRect();
          const relY = e.clientY - rect.top;

          let newParentId = targetItem.parentId;

          // 現在の配列からドラッグ項目を一時削除（後で挿入）
          const currentIndex = items.findIndex((i) => i.id === draggingId);
          items.splice(currentIndex, 1);

          // ターゲットの位置を再計算
          let targetIndex = items.findIndex((i) => i.id === targetId);

          if (
            targetItem.type === "folder" &&
            relY >= 10 &&
            !(relY > rect.height - 10 && items[targetIndex].isCollapsed)
          ) {
            // フォルダの中に入れる
            draggingItem.parentId = targetItem.id;
            targetItem.isCollapsed = false;
            // フォルダの直後に挿入 (配列上)
            items.splice(targetIndex + 1, 0, draggingItem);
          } else {
            // 並べ替え（同じ階層）
            draggingItem.parentId = targetItem.parentId;

            if (relY < rect.height / 2) {
              // 上に挿入
              items.splice(targetIndex, 0, draggingItem);
            } else {
              // 下に挿入
              items.splice(targetIndex + 1, 0, draggingItem);
            }
          }

          saveItems();
          renderTree();
        }

        function handleDragEnd(e) {
          this.classList.remove("dragging");
          document.querySelectorAll(".tree-item").forEach((el) => {
            el.classList.remove(
              "drag-over-top",
              "drag-over-bottom",
              "drag-over-folder"
            );
          });
          draggingId = null;
        }

        // ルートエリアへのドロップ（フォルダから出す）
        profilesContainer.addEventListener("dragover", (e) => {
          e.preventDefault();
        });
        profilesContainer.addEventListener("drop", (e) => {
          // コンテナ自体にドロップされた場合（アイテム上ではない）
          if (e.target === profilesContainer && draggingId) {
            e.preventDefault();
            const itemIndex = items.findIndex((i) => i.id === draggingId);
            if (itemIndex > -1) {
              const item = items[itemIndex];
              item.parentId = null; // ルートへ
              items.splice(itemIndex, 1);
              items.push(item); // 末尾へ
              saveItems();
              renderTree();
            }
          }
        });

        // --- 追加メニュー ---
        addBtnTrigger.addEventListener("click", (e) => {
          e.stopPropagation();
          addDropdown.classList.toggle("visible");
        });
        window.addEventListener("click", () => {
          addDropdown.classList.remove("visible");
          if (contextMenu.classList.contains("visible")) {
            contextMenu.classList.remove("visible");
            contextTargetId = null;
          }
        });

        addDropdown.addEventListener("click", (e) => {
          const action = e.target.closest(".add-option")?.dataset.action;
          if (action === "add-profile") {
            addNewItem("profile");
          } else if (action === "add-folder") {
            addNewItem("folder");
          }
        });

        const addNewItem = (type) => {
          const name = prompt(
            type === "profile" ? "プロファイル名:" : "フォルダ名:",
            type === "profile" ? "新規プロファイル" : "新規フォルダ"
          );
          if (!name || name.trim() === "") return;

          const newItem = {
            id: Date.now(),
            type: type,
            name: name.trim(),
            parentId: null, // ルートに追加
          };

          if (type === "profile") {
            newItem.min = 1;
            newItem.max = 35;
            newItem.exclude = "";
            newItem.useNames = false;
            newItem.names = "";
          } else {
            newItem.isCollapsed = false;
          }

          items.push(newItem);
          if (type === "profile") {
            activeProfileId = newItem.id;
            applyActiveProfileToInputs();
          }
          saveItems();
          renderTree();
        };

        const switchProfile = (id) => {
          activeProfileId = id;
          applyActiveProfileToInputs();
          saveItems();
          renderTree(); // ハイライト更新
          resetButton.click(); // プロファイル切り替え時にリセット
        };

        // --- コンテキストメニュー処理 ---
        const showContextMenu = (e, id) => {
          e.preventDefault();
          contextTargetId = id;
          const item = items.find((i) => i.id === id);
          if (!item) return;

          // メニュー項目の表示制御
          const loadBtn = contextMenu.querySelector('[data-action="load"]');
          const saveBtn = contextMenu.querySelector('[data-action="save"]');
          const exportBtn = contextMenu.querySelector('[data-action="export"]');

          if (item.type === "folder") {
            loadBtn.style.display = "none";
            saveBtn.style.display = "none";
            exportBtn.style.display = "none"; // フォルダのエクスポートは未実装
          } else {
            loadBtn.style.display = "flex";
            saveBtn.style.display = "flex";
            exportBtn.style.display = "flex";
          }

          contextMenu.style.top = `${e.clientY}px`;
          contextMenu.style.left = `${e.clientX}px`;
          contextMenu.classList.add("visible");
        };

        contextMenu.addEventListener("click", (e) => {
          const action = e.target.closest(".context-menu-item")?.dataset.action;
          if (!action || !contextTargetId) return;

          const item = items.find((i) => i.id === contextTargetId);
          if (!item) return;

          if (action === "load") {
            switchProfile(item.id);
          } else if (action === "save") {
            updateActiveProfileData(); // 現在の入力を保存
            item.min = parseInt(minNumInput.value);
            item.max = parseInt(maxNumInput.value);
            item.exclude = excludeNumbersInput.value;
            item.useNames = useNamesCheckbox.checked;
            item.names = namesListInput.value;
            saveItems();
            alert(`${item.name} に現在の設定を保存しました。`);
          } else if (action === "rename") {
            const newName = prompt("新しい名前:", item.name);
            if (newName && newName.trim() !== "") {
              item.name = newName.trim();
              if (item.id === activeProfileId)
                profileNameDisplay.textContent = item.name;
              saveItems();
              renderTree();
            }
          } else if (action === "export") {
            const exportData = JSON.stringify(item, null, 2);
            const blob = new Blob([exportData], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${item.name}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          } else if (action === "delete") {
            if (
              confirm(
                `本当に「${item.name}」を削除しますか？\n(フォルダの場合、中身も削除されます)`
              )
            ) {
              // 再帰的に削除対象IDを収集
              const idsToDelete = [item.id];
              if (item.type === "folder") {
                const collectChildren = (pid) => {
                  const children = items.filter((i) => i.parentId === pid);
                  children.forEach((c) => {
                    idsToDelete.push(c.id);
                    if (c.type === "folder") collectChildren(c.id);
                  });
                };
                collectChildren(item.id);
              }

              items = items.filter((i) => !idsToDelete.includes(i.id));

              // アクティブなものが消えた場合
              if (idsToDelete.includes(activeProfileId)) {
                const next = items.find((i) => i.type === "profile");
                activeProfileId = next ? next.id : null;
                if (activeProfileId) switchProfile(activeProfileId);
                else {
                  // 全部消えたらデフォルト作成
                  loadItems();
                }
              }
              saveItems();
              renderTree();
            }
          }
        });

        // インポート処理
        importProfileBtn.addEventListener("click", () =>
          importFileInput.click()
        );
        importFileInput.addEventListener("change", (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (ev) => {
            try {
              const data = JSON.parse(ev.target.result);
              if (!data.name) throw new Error("Invalid format");

              // ID衝突回避
              data.id = Date.now();
              data.parentId = null; // ルートにインポート
              // 名前重複回避
              let baseName = data.name;
              let c = 1;
              while (items.some((i) => i.name === data.name)) {
                data.name = `${baseName} (${c++})`;
              }

              items.push(data);
              saveItems();
              renderTree();

              if (data.type === "profile") {
                switchProfile(data.id);
              }
              alert(`インポートしました: ${data.name}`);
            } catch (err) {
              console.error(err);
              alert("読み込みに失敗しました。");
            }
            importFileInput.value = "";
          };
          reader.readAsText(file);
        });

        // 初期化
        loadItems();

        // ============================================
        // ゲームロジック (既存維持・バグ修正)
        // ============================================

        const playSound = (sound) => {
          const audio = sound.cloneNode();
          audio.volume = sound.volume;
          audio
            .play()
            .catch((e) => console.error("音声の再生に失敗しました:", e));
        };

        const initAudio = () => {
          Object.values(sounds).forEach((sound) => {
            sound
              .play()
              .then(() => sound.pause())
              .catch(() => {});
          });
          document.body.removeEventListener("click", initAudio);
          document.body.removeEventListener("touchstart", initAudio);
        };
        document.body.addEventListener("click", initAudio, { once: true });
        document.body.addEventListener("touchstart", initAudio, { once: true });

        // 状態管理
        let currentMode = "simple";
        let drawnNumbers = [];
        let isSpinning = false;
        let rotationDegree = 0;
        let cardGameActive = false;
        let availableCards = [];
        let rouletteSpinTimeoutId = null;
        let currentRouletteResultNumber = null;
        let currentRouletteFinalTargetAngle = 0;
        let timerModeInterval = null;
        let timerModeTimeLeft = 0;
        let timerModeIsRunning = false;

        // ルーレット音声用の状態管理
        let rouletteAudioContext = {
          loopId: null,
          lastAngle: 0,
          angleSinceLastTick: 0,
          segmentAngle: 0,
          lastTickTimestamp: 0,
          minTimeBetweenTicks: 100,
        };

        // --- テーマ切り替え処理 (復活) ---
        const themes = [
          { name: "Blue", color: "#1a73e8" },
          { name: "Pink", color: "#ff007b" },
          { name: "Green", color: "#1e8e3e" },
          { name: "Red", color: "#d93025" },
          { name: "Purple", color: "#8e44ad" },
          { name: "Orange", color: "#f0932b" },
        ];
        let currentThemeIndex = 0;

        const hexToHsl = (hex) => {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          let r = parseInt(result[1], 16) / 255;
          let g = parseInt(result[2], 16) / 255;
          let b = parseInt(result[3], 16) / 255;
          const max = Math.max(r, g, b),
            min = Math.min(r, g, b);
          let h,
            s,
            l = (max + min) / 2;
          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return { h: h * 360, s: s * 100, l: l * 100 };
        };

        const hslToHex = (h, s, l) => {
          s /= 100;
          l /= 100;
          const c = (1 - Math.abs(2 * l - 1)) * s;
          const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
          const m = l - c / 2;
          let r = 0,
            g = 0,
            b = 0;
          if (0 <= h && h < 60) {
            r = c;
            g = x;
            b = 0;
          } else if (60 <= h && h < 120) {
            r = x;
            g = c;
            b = 0;
          } else if (120 <= h && h < 180) {
            r = 0;
            g = c;
            b = x;
          } else if (180 <= h && h < 240) {
            r = 0;
            g = x;
            b = c;
          } else if (240 <= h && h < 300) {
            r = x;
            g = 0;
            b = c;
          } else if (300 <= h && h < 360) {
            r = c;
            g = 0;
            b = x;
          }
          r = Math.round((r + m) * 255)
            .toString(16)
            .padStart(2, "0");
          g = Math.round((g + m) * 255)
            .toString(16)
            .padStart(2, "0");
          b = Math.round((b + m) * 255)
            .toString(16)
            .padStart(2, "0");
          return `#${r}${g}${b}`;
        };

        const applyTheme = (color) => {
          const hsl = hexToHsl(color);
          const root = document.documentElement;
          root.style.setProperty("--color-primary", color);
          root.style.setProperty(
            "--color-primary-dark",
            hslToHex(hsl.h, hsl.s, hsl.l - 10)
          );
          root.style.setProperty(
            "--color-primary-light",
            hslToHex(hsl.h, hsl.s, hsl.l + 85)
          );
          root.style.setProperty(
            "--color-primary-disabled",
            hslToHex(hsl.h, hsl.s, hsl.l + 30)
          );
        };

        themeToggleButton.addEventListener("click", () => {
          currentThemeIndex = (currentThemeIndex + 1) % themes.length;
          applyTheme(themes[currentThemeIndex].color);
        });
        applyTheme(themes[currentThemeIndex].color);

        // --- フォーカスモード切り替え (復活) ---
        focusToggleButton.addEventListener("click", () => {
          body.classList.toggle("focus-mode-on");
          body.classList.toggle("focus-mode-off");
        });

        // --- 共通関数 ---
        const getAvailableNumbers = () => {
          // 名前モードが有効なら名前リストを返す
          if (useNamesCheckbox.checked) {
            const raw = namesListInput.value || "";
            // カンマまたは改行で分割してトリム、空白を除去
            const names = raw
              .split(/,|\n/)
              .map((s) => s.trim())
              .filter((s) => s !== "");
            // 一意化
            const uniqueNames = Array.from(new Set(names));
            // 重複なしが有効でかつ既に引かれているものは除外
            const available = uniqueNames.filter((name) => {
              if (noDuplicatesCheckbox.checked && drawnNumbers.includes(name)) {
                return false;
              }
              return true;
            });
            if (available.length === 0) {
              return [];
            }
            return available;
          }

          // 数値モード
          const min = parseInt(minNumInput.value);
          const max = parseInt(maxNumInput.value);
          if (isNaN(min) || isNaN(max) || min >= max) {
            alert("有効な範囲を正しく入力してください（最小値 < 最大値）。");
            return null;
          }

          const excludeString = excludeNumbersInput.value;
          const excludedNumbers = excludeString
            .split(",")
            .map((n) => parseInt(n.trim()))
            .filter((n) => !isNaN(n));

          const available = [];
          for (let i = min; i <= max; i++) {
            if (
              (!noDuplicatesCheckbox.checked || !drawnNumbers.includes(i)) &&
              !excludedNumbers.includes(i) // 除外リストチェック
            ) {
              available.push(i);
            }
          }
          return available;
        };

        const addToHistory = (number) => {
          drawnNumbers.push(number);
          const historyItem = document.createElement("li");
          historyItem.textContent = number;
          historyList.prepend(historyItem);
        };

        const showResultPopup = (number, duration = 1.5) => {
          resultPopup.textContent = number;
          resultOverlay.classList.remove("hidden");
          setTimeout(() => {
            resultOverlay.classList.add("hidden");
          }, duration * 1000);
        };

        const setControlsDisabled = (disabled) => {
          isSpinning = disabled;
          minNumInput.disabled = disabled;
          maxNumInput.disabled = disabled;
          excludeNumbersInput.disabled = disabled;
          noDuplicatesCheckbox.disabled = disabled;
          startButton.disabled = disabled;
          useNamesCheckbox.disabled = disabled;
          namesListInput.disabled = disabled;
        };

        // --- モード切り替え ---
        const setActiveMode = (mode) => {
          if (currentMode === mode) return;
          if (isSpinning && !cardGameActive) return;
          if (currentMode === "card" && cardGameActive) {
            cardGameActive = false;
            cardGrid.innerHTML = "";
            availableCards = [];
          }

          const gameButtons = document.querySelector(".buttons");
          if (mode === "timer") {
            gameButtons.style.display = "none";
            timerMinutesInput.value = 0;
            timerSecondsInput.value = 0;
            timerModeTimeLeft = 0;
            updateTimerDisplay();
            timerPauseBtn.disabled = true;
            timerResetBtn.disabled = true;
            timerMinutesInput.disabled = false;
            timerSecondsInput.disabled = false;
            timerStartBtn.textContent = "スタート";
            clearInterval(timerModeInterval);
            timerModeIsRunning = false;
          } else {
            gameButtons.style.display = "flex";
          }

          currentMode = mode;
          const activeButton = document.querySelector(
            `.mode-btn[data-mode="${mode}"]`
          );
          modeHighlight.style.width = `${activeButton.offsetWidth}px`;
          modeHighlight.style.transform = `translateX(${activeButton.offsetLeft}px)`;
          modeButtons.forEach((btn) => btn.classList.remove("active"));
          activeButton.classList.add("active");
          modeContents.forEach((content) => content.classList.remove("active"));
          document
            .getElementById(`${currentMode}-mode-area`)
            .classList.add("active");
          if (currentMode === "card") {
            const availableNumbers = getAvailableNumbers();
            if (availableNumbers && availableNumbers.length > 0) {
              startCardMode(availableNumbers);
            } else {
              cardMessage.textContent = "すべての数字を引き終えました！";
              setControlsDisabled(false);
            }
          } else {
            startButton.textContent = "スタート！";
            setControlsDisabled(false);
          }
        };

        modeButtons.forEach((btn) => {
          btn.addEventListener("click", () => setActiveMode(btn.dataset.mode));
        });

        // モード選択のスワイプ/ドラッグロジック
        let isDraggingMode = false,
          startX,
          currentDragMode;
        const handleModeDragStart = (e) => {
          isDraggingMode = true;
          startX = e.pageX || e.touches[0].pageX;
          currentDragMode = currentMode;
          modeSelector.style.cursor = "grabbing";
        };
        const handleModeDragMove = (e) => {
          if (!isDraggingMode) return;
          // e.preventDefault(); // ツリーのDnDと競合する可能性があるので一旦コメントアウト
          const x = e.pageX || e.touches[0].pageX;
          const walk = x - startX;
          const buttonWidth = modeButtons[0].offsetWidth;
          const modeOrder = Array.from(modeButtons).map(
            (btn) => btn.dataset.mode
          );
          const currentIndex = modeOrder.indexOf(currentDragMode);
          if (walk > buttonWidth / 2 && currentIndex < modeOrder.length - 1) {
            setActiveMode(modeOrder[currentIndex + 1]);
            isDraggingMode = false;
          } else if (walk < -buttonWidth / 2 && currentIndex > 0) {
            setActiveMode(modeOrder[currentIndex - 1]);
            isDraggingMode = false;
          }
        };
        const handleModeDragEnd = () => {
          isDraggingMode = false;
          modeSelector.style.cursor = "grab";
        };
        modeSelector.addEventListener("mousedown", handleModeDragStart);
        modeSelector.addEventListener("touchstart", handleModeDragStart);
        modeSelector.addEventListener("mousemove", handleModeDragMove);
        modeSelector.addEventListener("touchmove", handleModeDragMove);
        modeSelector.addEventListener("mouseup", handleModeDragEnd);
        modeSelector.addEventListener("touchend", handleModeDragEnd);
        modeSelector.addEventListener("mouseleave", handleModeDragEnd);

        window.addEventListener("load", () => {
          setTimeout(() => {
            const activeButton = document.querySelector(".mode-btn.active");
            if (activeButton) {
              modeHighlight.style.width = `${activeButton.offsetWidth}px`;
              modeHighlight.style.transform = `translateX(${activeButton.offsetLeft}px)`;
            }
          }, 50);
        });

        // ルーレット音声のループ処理
        const rouletteAudioTick = () => {
          if (!isSpinning) {
            stopRouletteAudio();
            return;
          }

          const transform = window.getComputedStyle(rouletteWheel).transform;
          if (transform !== "none") {
            const matrix = new DOMMatrix(transform);
            const currentAngle =
              Math.atan2(matrix.b, matrix.a) * (180 / Math.PI);

            let delta = currentAngle - rouletteAudioContext.lastAngle;
            if (delta < -270) {
              delta += 360;
            } else if (delta > 270) {
              delta -= 360;
            }

            rouletteAudioContext.angleSinceLastTick += Math.abs(delta);
            rouletteAudioContext.lastAngle = currentAngle;

            while (
              rouletteAudioContext.angleSinceLastTick >=
              rouletteAudioContext.segmentAngle
            ) {
              rouletteAudioContext.angleSinceLastTick -=
                rouletteAudioContext.segmentAngle;

              const now = Date.now();
              if (
                now - rouletteAudioContext.lastTickTimestamp >
                rouletteAudioContext.minTimeBetweenTicks
              ) {
                playSound(sounds.rouletteTick);
                rouletteAudioContext.lastTickTimestamp = now;
              }
            }
          }

          rouletteAudioContext.loopId =
            requestAnimationFrame(rouletteAudioTick);
        };

        const startRouletteAudio = (segmentAngle) => {
          stopRouletteAudio();

          const initialTransform =
            window.getComputedStyle(rouletteWheel).transform;
          const initialMatrix = new DOMMatrix(initialTransform);
          rouletteAudioContext = {
            ...rouletteAudioContext,
            loopId: null,
            lastAngle:
              Math.atan2(initialMatrix.b, initialMatrix.a) * (180 / Math.PI),
            angleSinceLastTick: 0,
            segmentAngle: segmentAngle,
            lastTickTimestamp: 0,
          };

          rouletteAudioContext.loopId =
            requestAnimationFrame(rouletteAudioTick);
        };

        const stopRouletteAudio = () => {
          if (rouletteAudioContext.loopId) {
            cancelAnimationFrame(rouletteAudioContext.loopId);
            rouletteAudioContext.loopId = null;
          }
        };

        // --- スタートボタン処理 ---
        startButton.addEventListener("click", () => {
          if (currentMode === "roulette" && isSpinning) {
            stopRouletteAudio();
            playSound(sounds.rouletteResult);

            clearTimeout(rouletteSpinTimeoutId);

            rouletteWheel.style.transition =
              "transform 1.5s cubic-bezier(0.2, 0.95, 0.3, 1)";
            rouletteWheel.style.transform = `rotate(${currentRouletteFinalTargetAngle}deg)`;

            setTimeout(() => {
              rouletteWheel.style.transition =
                "transform 5s cubic-bezier(0.1, 0.8, 0.2, 1)";
            }, 1500);

            showResultPopup(currentRouletteResultNumber, 3);
            addToHistory(currentRouletteResultNumber);
            setControlsDisabled(false);
            startButton.textContent = "スタート！";
            startButton.disabled = false;
            rouletteSpinTimeoutId = null;
            return;
          }

          if (isSpinning) return;
          const availableNumbers = getAvailableNumbers();
          if (!availableNumbers) return;
          if (availableNumbers.length === 0) {
            alert("すべての数字を引き終えました！リセットしてください。");
            return;
          }
          setControlsDisabled(true);
          body.classList.add("focus-mode-on");
          body.classList.remove("focus-mode-off");

          switch (currentMode) {
            case "simple":
              startSimpleMode(availableNumbers);
              break;
            case "roulette":
              startRouletteMode(availableNumbers);
              break;
            case "card":
              startCardMode(availableNumbers);
              break;
          }
        });

        // --- 各モードの実行関数 ---
        const startSimpleMode = (numbers) => {
          resultDisplay.classList.remove("zoom");
          void resultDisplay.offsetWidth;

          const spinInterval = setInterval(() => {
            resultDisplay.textContent =
              numbers[Math.floor(Math.random() * numbers.length)];
            playSound(sounds.simpleTick);
          }, 50);

          setTimeout(() => {
            clearInterval(spinInterval);
            const resultNumber =
              numbers[Math.floor(Math.random() * numbers.length)];
            resultDisplay.textContent = resultNumber;
            resultDisplay.classList.add("zoom");
            playSound(sounds.simpleResult);
            addToHistory(resultNumber);
            setControlsDisabled(false);
          }, 2000);
        };

        const startRouletteMode = (numbers) => {
          const totalNumbersOnWheel = numbers.length;
          const segmentAngle = 360 / totalNumbersOnWheel;

          const colors = [
            "#ffadad",
            "#ffd6a5",
            "#fdffb6",
            "#caffbf",
            "#9bf6ff",
            "#a0c4ff",
            "#bdb2ff",
            "#ffc6ff",
          ];
          const gradientStartAngle = 270 - segmentAngle / 2;
          let gradient = `conic-gradient(from ${gradientStartAngle}deg, `;
          rouletteWheel.innerHTML = "";

          for (let i = 0; i < totalNumbersOnWheel; i++) {
            const label = numbers[i];
            gradient += `${colors[i % colors.length]} ${i * segmentAngle}deg ${
              (i + 1) * segmentAngle
            }deg`;
            if (i < totalNumbersOnWheel - 1) gradient += ", ";

            const numberDiv = document.createElement("div");
            numberDiv.className = "number";
            numberDiv.style.transform = `rotate(${
              i * segmentAngle + segmentAngle / 2
            }deg)`;

            if (noDuplicatesCheckbox.checked && drawnNumbers.includes(label)) {
              numberDiv.classList.add("drawn");
            }

            const span = document.createElement("span");
            span.textContent = label;

            // ★★★ 文字数に応じてフォントサイズを調整 ★★★
            const length = String(label).length;
            if (length > 10) {
              span.style.fontSize = "0.5rem";
            } else if (length > 7) {
              span.style.fontSize = "0.7rem";
            } else if (length > 5) {
              span.style.fontSize = "0.85rem";
            } else {
              span.style.fontSize = "1.1rem"; // デフォルト（短い文字用）
            }
            // 長い名前が改行されないようにする
            span.style.whiteSpace = "nowrap";

            numberDiv.appendChild(span);
            rouletteWheel.appendChild(numberDiv);
          }
          gradient += ")";
          rouletteWheel.style.background = gradient;

          const currentAngle = ((rotationDegree % 360) + 360) % 360;
          const resultNumber =
            numbers[Math.floor(Math.random() * numbers.length)];
          const resultIndexOnWheel = numbers.indexOf(resultNumber);

          const randomOffset = (Math.random() - 0.5) * segmentAngle * 0.75;
          const targetSegmentCenterAngle =
            resultIndexOnWheel * segmentAngle + segmentAngle / 2;
          const finalTargetAngle = targetSegmentCenterAngle + randomOffset;

          currentRouletteResultNumber = resultNumber;
          currentRouletteFinalTargetAngle = finalTargetAngle;

          const targetViewAngle = (270 - finalTargetAngle + 360) % 360;
          let rotationNeeded = targetViewAngle - currentAngle;
          if (rotationNeeded < 0) rotationNeeded += 360;
          const fullRotations = 360 * (Math.floor(Math.random() * 4) + 5);
          const rotationAmount = fullRotations + rotationNeeded;
          rotationDegree += rotationAmount;
          rouletteWheel.style.transform = `rotate(${rotationDegree}deg)`;

          startRouletteAudio(segmentAngle);

          startButton.textContent = "スキップ";
          startButton.disabled = false;

          rouletteSpinTimeoutId = setTimeout(() => {
            playSound(sounds.rouletteResult);
            showResultPopup(resultNumber);
            addToHistory(resultNumber);
            setControlsDisabled(false);
            startButton.textContent = "スタート！";
            rouletteSpinTimeoutId = null;
          }, 5100);
        };

        const startCardMode = (numbers) => {
          availableCards = [...numbers];
          cardGrid.innerHTML = "";
          cardMessage.textContent = "好きなカードを1枚選んでください";
          for (let i = availableCards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableCards[i], availableCards[j]] = [
              availableCards[j],
              availableCards[i],
            ];
          }
          availableCards.forEach((num) => {
            const card = document.createElement("div");
            card.className = "card";
            card.dataset.number = num;
            card.innerHTML = `<div class="card-inner"><div class="card-front"></div><div class="card-back">${num}</div></div>`;
            card.addEventListener("click", handleCardClick, { once: true });
            cardGrid.appendChild(card);
          });
          cardGameActive = true;
          setControlsDisabled(true);
          startButton.disabled = false;
        };

        const handleCardClick = (e) => {
          const clickedCard = e.currentTarget;
          const resultNumber = parseInt(clickedCard.dataset.number);
          playSound(sounds.cardFlip);
          clickedCard.classList.add("flipped");
          const resultValue = isNaN(resultNumber)
            ? clickedCard.dataset.number
            : resultNumber;
          addToHistory(resultValue);
          const idx = availableCards.indexOf(resultValue);
          if (idx !== -1) availableCards.splice(idx, 1);
          if (availableCards.length === 0) {
            cardMessage.textContent = "すべてのカードを引きました！";
            cardGameActive = false;
            setControlsDisabled(false);
          }
        };

        // --- リセットボタン処理 ---
        resetButton.addEventListener("click", () => {
          drawnNumbers = [];
          historyList.innerHTML = "";
          setControlsDisabled(false);
          cardGameActive = false;
          resultDisplay.textContent = "?";
          resultDisplay.classList.remove("zoom");
          rouletteWheel.style.transition = "none";
          rotationDegree = 0;
          rouletteWheel.style.transform = `rotate(${rotationDegree}deg)`;
          rouletteWheel.innerHTML = "";
          rouletteWheel.style.background = "none";
          setTimeout(() => {
            rouletteWheel.style.transition =
              "transform 5s cubic-bezier(0.1, 0.8, 0.2, 1)";
          }, 50);
          cardGrid.innerHTML = "";
          cardMessage.textContent = "スタートボタンを押してカードを準備";
          availableCards = [];
          startButton.textContent =
            currentMode === "card" ? "カードを準備" : "スタート！";

          if (currentMode === "card") {
            const availableNumbers = getAvailableNumbers();
            if (availableNumbers && availableNumbers.length > 0) {
              startCardMode(availableNumbers);
            } else {
              cardMessage.textContent = "すべての数字を引き終えました！";
              setControlsDisabled(false);
            }
          }

          if (rouletteSpinTimeoutId) {
            clearTimeout(rouletteSpinTimeoutId);
            rouletteSpinTimeoutId = null;
          }

          stopRouletteAudio();
          body.classList.remove("focus-mode-on");
        });

        // タイマーモードのロジック
        const updateTimerDisplay = () => {
          const minutes = Math.floor(timerModeTimeLeft / 60);
          const seconds = timerModeTimeLeft % 60;
          timerDisplayMode.textContent = `${String(minutes).padStart(
            2,
            "0"
          )}:${String(seconds).padStart(2, "0")}`;
        };

        const startTimerMode = () => {
          if (timerModeIsRunning) return;
          if (timerModeTimeLeft <= 0) {
            timerModeTimeLeft =
              parseInt(timerMinutesInput.value || "0") * 60 +
              parseInt(timerSecondsInput.value || "0");
            if (timerModeTimeLeft <= 0) return;
          }
          timerModeIsRunning = true;
          timerStartBtn.textContent = "再開";
          timerPauseBtn.disabled = false;
          timerResetBtn.disabled = false;
          timerMinutesInput.disabled = true;
          timerSecondsInput.disabled = true;

          timerModeInterval = setInterval(() => {
            if (timerModeTimeLeft <= 0) {
              clearInterval(timerModeInterval);
              timerModeIsRunning = false;
              timerStartBtn.textContent = "スタート";
              timerPauseBtn.disabled = true;
              alert("時間になりました！");
            } else {
              timerModeTimeLeft--;
              updateTimerDisplay();
            }
          }, 1000);
        };

        const pauseTimerMode = () => {
          clearInterval(timerModeInterval);
          timerModeIsRunning = false;
          timerStartBtn.textContent = "再開";
        };

        const resetTimerMode = () => {
          clearInterval(timerModeInterval);
          timerModeIsRunning = false;
          timerModeTimeLeft =
            parseInt(timerMinutesInput.value || "0") * 60 +
            parseInt(timerSecondsInput.value || "0");
          updateTimerDisplay();
          timerStartBtn.textContent = "スタート";
          timerPauseBtn.disabled = true;
          timerResetBtn.disabled = true;
          timerMinutesInput.disabled = false;
          timerSecondsInput.disabled = false;
        };

        const updateTimerFromInput = () => {
          if (!timerModeIsRunning) {
            timerModeTimeLeft =
              parseInt(timerMinutesInput.value || "0") * 60 +
              parseInt(timerSecondsInput.value || "0");
            updateTimerDisplay();
          }
        };
        timerMinutesInput.addEventListener("input", updateTimerFromInput);
        timerSecondsInput.addEventListener("input", updateTimerFromInput);
        timerStartBtn.addEventListener("click", startTimerMode);
        timerPauseBtn.addEventListener("click", pauseTimerMode);
        timerResetBtn.addEventListener("click", resetTimerMode);

        updateTimerFromInput();
      });

      let lastTouchEnd = 0;
      document.addEventListener(
        "touchend",
        function (event) {
          const now = new Date().getTime();
          if (now - lastTouchEnd <= 300) {
            event.preventDefault();
          }
          lastTouchEnd = now;
        },
        false
      );
    </script>
  </body>
</html>